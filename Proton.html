<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>ShadowLink | Secure P2P</title>
    
    <!-- React & DOM -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>    
    
    <!-- Tailwind -->
    <!-- <script src="https://cdn.tailwindcss.com"></script> -->
    <script src="https://unpkg.com/@tailwindcss/browser@4"></script>
    
    <!-- QR Tools -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrious/4.0.2/qrious.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>
    
    <!-- Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;500;700&family=JetBrains+Mono:wght@400;700&display=swap');
        
        :root {
            --neon-cyan: #00f3ff;
            --neon-purple: #bc13fe;
            --bg-dark: #050510;
        }

        body {
            background-color: var(--bg-dark);
            color: #e2e8f0;
            font-family: 'Space Grotesk', sans-serif;
            overflow: hidden;
            touch-action: none;
        }

        .app-height {
            height: 100vh;
            height: 100dvh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* CRT/Scanline Effects */
        .scanline {
            width: 100%; height: 2px;
            background: var(--neon-cyan);
            position: absolute;
            animation: scan 2s linear infinite;
            box-shadow: 0 0 15px var(--neon-cyan);
            z-index: 50;
            pointer-events: none;
        }
        @keyframes scan { 0% { top: 0%; opacity: 0; } 50% { opacity: 1; } 100% { top: 100%; opacity: 0; } }

        .glass-panel {
            background: rgba(15, 23, 42, 0.7);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.08);
        }

        /* Utilities */
        .font-mono { font-family: 'JetBrains Mono', monospace; }
        .hide-scrollbar::-webkit-scrollbar { display: none; }
        .hide-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        .fade-in { animation: fadeIn 0.3s ease-in; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        /* Messages */
        .msg-bubble { max-width: 85%; padding: 10px 14px; border-radius: 16px; position: relative; word-break: break-word; }
        .msg-me { background: linear-gradient(135deg, #0891b2, #0e7490); color: white; border-bottom-right-radius: 2px; margin-left: auto; }
        .msg-other { background: #1e293b; color: #e2e8f0; border-bottom-left-radius: 2px; margin-right: auto; }
        .msg-sys { text-align: center; width: 100%; margin: 8px 0; }
        .sys-pill { background: rgba(30, 41, 59, 0.8); color: #22d3ee; font-size: 10px; padding: 4px 12px; border-radius: 999px; font-family: 'JetBrains Mono', monospace; border: 1px solid rgba(34, 211, 238, 0.2); }

        .pb-safe { padding-bottom: env(safe-area-inset-bottom); }

        /* Recording Pulse */
        .pulse-ring {
            box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7);
            animation: pulse-red 1.5s infinite cubic-bezier(0.66, 0, 0, 1);
        }
        @keyframes pulse-red {
            to { box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); }
        }

        /* Video Call */
        .video-container {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* Mirror effect */
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo, useCallback } = React;

        // --- CONFIG ---
        const CHUNK_SIZE = 250;
        const ICE_SERVERS = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };
        const FILE_CHUNK_SIZE = 16384; 
        
        // --- UTILS ---
        const buf2hex = (buf) => [...new Uint8Array(buf)].map(x => x.toString(16).padStart(2, '0')).join('');
        const hex2buf = (hex) => new Uint8Array(hex.match(/.{1,2}/g).map(byte => parseInt(byte, 16))).buffer;
        
        const arrayBufferToBase64 = (buffer) => {
            let binary = '';
            const bytes = new Uint8Array(buffer);
            for (let i = 0; i < bytes.byteLength; i++) binary += String.fromCharCode(bytes[i]);
            return window.btoa(binary);
        };
        const base64ToArrayBuffer = (base64) => {
            const binary_string = window.atob(base64);
            const len = binary_string.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) bytes[i] = binary_string.charCodeAt(i);
            return bytes.buffer;
        };

        const formatTime = (seconds) => {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        };

        // --- COMPONENTS ---

        const Icon = ({ name, size = 24, className, onClick }) => {
            useEffect(() => { lucide.createIcons(); }, [name]);
            return <i data-lucide={name} width={size} height={size} className={className} onClick={onClick}></i>;
        };

        const QRAnimator = ({ data, label }) => {
            const [index, setIndex] = useState(0);
            const canvasRef = useRef(null);
            
            const chunks = useMemo(() => {
                if(!data) return [];
                const str = typeof data === 'string' ? data : JSON.stringify(data);
                const b64 = btoa(str); 
                const total = Math.ceil(b64.length / CHUNK_SIZE);
                const arr = [];
                for(let i=0; i<total; i++) {
                    arr.push(`SL:${i}:${total}:${b64.slice(i*CHUNK_SIZE, (i+1)*CHUNK_SIZE)}`);
                }
                return arr;
            }, [data]);

            useEffect(() => {
                if(chunks.length <= 1) return;
                const interval = setInterval(() => {
                    setIndex(prev => (prev + 1) % chunks.length);
                }, 250);
                return () => clearInterval(interval);
            }, [chunks]);

            useEffect(() => {
                if(canvasRef.current && chunks.length > 0) {
                    new QRious({
                        element: canvasRef.current,
                        value: chunks[index],
                        size: 250,
                        level: 'L',
                        foreground: '#000',
                        background: '#fff'
                    });
                }
            }, [index, chunks]);

            return (
                <div className="flex flex-col items-center bg-white p-4 rounded-xl shadow-[0_0_30px_rgba(0,243,255,0.2)]">
                    <canvas ref={canvasRef} className="rounded-lg mb-2"></canvas>
                    <div className="w-full bg-slate-200 h-1 rounded overflow-hidden">
                        <div className="h-full bg-cyan-500 transition-all duration-100" 
                             style={{width: `${((index+1)/chunks.length)*100}%`}}></div>
                    </div>
                    <p className="text-black font-mono text-xs mt-2 font-bold">{label} ({index+1}/{chunks.length})</p>
                </div>
            );
        };

        const QRScanner = ({ onScan }) => {
            const videoRef = useRef(null);
            const canvasRef = useRef(null);
            const [status, setStatus] = useState("Initializing Camera...");

            const scanLoop = useCallback(() => {
                const video = videoRef.current;
                const canvas = canvasRef.current;
                if(!video || !canvas) return;

                if (video.readyState === video.HAVE_ENOUGH_DATA) {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    const ctx = canvas.getContext("2d", { willReadFrequently: true });
                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const code = jsQR(imageData.data, imageData.width, imageData.height);
                    
                    if (code && code.data.startsWith('SL:')) {
                        setStatus("Packet Detected");
                        onScan(code.data);
                    } else {
                        setStatus("Scanning...");
                    }
                }
                requestAnimationFrame(scanLoop);
            }, [onScan]);

            useEffect(() => {
                let stream = null;
                navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } })
                    .then(s => {
                        stream = s;
                        if(videoRef.current) {
                            videoRef.current.srcObject = stream;
                            videoRef.current.play().catch(e => console.error(e));
                            requestAnimationFrame(scanLoop);
                        }
                    })
                    .catch(err => setStatus("Camera Error: " + err.message));
                
                return () => {
                    if(stream) stream.getTracks().forEach(t => t.stop());
                };
            }, [scanLoop]);

            return (
                <div className="relative w-full max-w-sm aspect-square bg-black rounded-2xl overflow-hidden border-2 border-cyan-500/50 shadow-2xl">
                    <video ref={videoRef} className="absolute inset-0 w-full h-full object-cover opacity-80" muted playsInline></video>
                    <canvas ref={canvasRef} className="hidden"></canvas>
                    <div className="scanline"></div>
                    <div className="absolute bottom-4 left-0 right-0 text-center">
                        <span className={`text-xs px-3 py-1 rounded-full font-mono backdrop-blur-md transition-colors ${status === "Packet Detected" ? "bg-green-500/80 text-white" : "bg-black/60 text-cyan-400"}`}>{status}</span>
                    </div>
                </div>
            );
        };

        const IdentityModal = ({ fingerprint, onClose }) => {
            if (!fingerprint) return null;
            return (
                <div className="fixed inset-0 z-[100] bg-black/80 backdrop-blur-sm flex items-center justify-center p-4 fade-in">
                    <div className="bg-slate-900 border border-slate-700 p-8 rounded-3xl max-w-sm w-full text-center relative shadow-2xl">
                        <button onClick={onClose} className="absolute top-4 right-4 p-2 text-slate-500 hover:text-white">
                            <Icon name="x" size={20} />
                        </button>
                        <div className="w-16 h-16 bg-cyan-500/10 rounded-full flex items-center justify-center mx-auto mb-4 border border-cyan-500/30">
                            <Icon name="shield-check" size={32} className="text-cyan-400" />
                        </div>
                        <h3 className="text-xl font-bold text-white mb-2">Safety Number</h3>
                        <p className="text-slate-400 text-sm mb-6">Compare with peer.</p>
                        <div className="bg-black/50 p-6 rounded-2xl border border-slate-800 mb-6">
                            <div className="text-5xl mb-4 tracking-widest">{fingerprint.emoji}</div>
                            <div className="font-mono text-cyan-400 text-lg tracking-[0.2em] break-all">{fingerprint.hex}</div>
                        </div>
                        <button onClick={onClose} className="w-full py-3 bg-cyan-600 hover:bg-cyan-500 rounded-xl font-bold text-white transition-colors">Verified</button>
                    </div>
                </div>
            );
        };

        // --- CALL UI COMPONENT ---
        const CallOverlay = ({ status, localStream, remoteStream, onAnswer, onHangup, isVideo }) => {
            const localVideoRef = useRef(null);
            const remoteVideoRef = useRef(null);

            useEffect(() => {
                if (localVideoRef.current && localStream) {
                    localVideoRef.current.srcObject = localStream;
                }
            }, [localStream]);

            useEffect(() => {
                if (remoteVideoRef.current && remoteStream) {
                    remoteVideoRef.current.srcObject = remoteStream;
                }
            }, [remoteStream]);

            if (status === 'IDLE') return null;

            return (
                <div className="fixed inset-0 z-[70] bg-black flex flex-col items-center justify-center app-height animate-fade-in">
                    {/* Remote Video (Background) */}
                    <div className="absolute inset-0 bg-slate-900">
                        {remoteStream ? (
                            <video ref={remoteVideoRef} autoPlay playsInline className="w-full h-full object-cover" />
                        ) : (
                            <div className="w-full h-full flex items-center justify-center">
                                <div className="w-32 h-32 rounded-full bg-slate-800 animate-pulse flex items-center justify-center">
                                    <Icon name="user" size={64} className="text-slate-600" />
                                </div>
                            </div>
                        )}
                    </div>

                    {/* Local Video (PiP) */}
                    {localStream && isVideo && (
                        <div className="absolute top-4 right-4 w-32 h-48 bg-black rounded-xl overflow-hidden shadow-2xl border border-slate-700">
                            <video ref={localVideoRef} autoPlay playsInline muted className="w-full h-full object-cover transform scale-x-[-1]" />
                        </div>
                    )}

                    {/* Call Status / Controls */}
                    <div className="absolute bottom-10 w-full px-8 pb-safe">
                        <div className="bg-black/60 backdrop-blur-md rounded-3xl p-6 border border-white/10 shadow-2xl">
                            <div className="text-center mb-8">
                                <h3 className="text-2xl font-bold text-white mb-2">
                                    {status === 'INCOMING' ? 'Incoming Call...' : status === 'OUTGOING' ? 'Calling...' : 'Connected'}
                                </h3>
                                <div className="text-cyan-400 font-mono text-sm animate-pulse">
                                    {status === 'ACTIVE' ? 'SECURE FEED LIVE' : 'ENCRYPTING SIGNAL...'}
                                </div>
                            </div>

                            <div className="flex items-center justify-center gap-8">
                                {status === 'INCOMING' ? (
                                    <>
                                        <button onClick={onHangup} className="p-4 bg-red-500 rounded-full text-white shadow-lg hover:bg-red-600 transition-all">
                                            <Icon name="phone-off" size={32} />
                                        </button>
                                        <button onClick={onAnswer} className="p-4 bg-green-500 rounded-full text-white shadow-lg hover:bg-green-600 transition-all animate-bounce">
                                            <Icon name="phone" size={32} />
                                        </button>
                                    </>
                                ) : (
                                    <button onClick={onHangup} className="p-4 bg-red-500 rounded-full text-white shadow-lg hover:bg-red-600 transition-all w-full max-w-[200px] flex items-center justify-center gap-2">
                                        <Icon name="phone-off" size={24} /> <span className="font-bold">End Call</span>
                                    </button>
                                )}
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        // --- CAMERA COMPONENT ---
        const CameraModal = ({ onClose, onCapture }) => {
            const videoRef = useRef(null);
            const canvasRef = useRef(null);
            const mediaRecorderRef = useRef(null);
            const [stream, setStream] = useState(null);
            const [mode, setMode] = useState('PHOTO'); // PHOTO or VIDEO
            const [isRecording, setIsRecording] = useState(false);
            const [preview, setPreview] = useState(null); // { type: 'image'|'video', url, blob }
            const [timer, setTimer] = useState(0);

            useEffect(() => {
                let s = null;
                navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: "environment" }, 
                    audio: true 
                }).then(mediaStream => {
                    s = mediaStream;
                    setStream(mediaStream);
                    if(videoRef.current) {
                        videoRef.current.srcObject = mediaStream;
                        videoRef.current.play();
                    }
                }).catch(err => console.error("Cam Access Denied", err));
                return () => {
                    if(s) s.getTracks().forEach(t => t.stop());
                }
            }, []);

            useEffect(() => {
                let interval;
                if(isRecording) {
                    interval = setInterval(() => setTimer(t => t+1), 1000);
                } else {
                    setTimer(0);
                }
                return () => clearInterval(interval);
            }, [isRecording]);

            const takePhoto = () => {
                if(!videoRef.current || !canvasRef.current) return;
                const w = videoRef.current.videoWidth;
                const h = videoRef.current.videoHeight;
                canvasRef.current.width = w;
                canvasRef.current.height = h;
                const ctx = canvasRef.current.getContext('2d');
                ctx.drawImage(videoRef.current, 0, 0, w, h);
                canvasRef.current.toBlob(blob => {
                    setPreview({ type: 'image', url: URL.createObjectURL(blob), blob });
                }, 'image/jpeg', 0.85);
            };

            const toggleVideo = () => {
                if(isRecording) {
                    mediaRecorderRef.current.stop();
                    setIsRecording(false);
                } else {
                    const chunks = [];
                    const mr = new MediaRecorder(stream, { mimeType: 'video/webm' });
                    mr.ondataavailable = e => { if(e.data.size > 0) chunks.push(e.data); };
                    mr.onstop = () => {
                        const blob = new Blob(chunks, { type: 'video/webm' });
                        setPreview({ type: 'video', url: URL.createObjectURL(blob), blob });
                    };
                    mr.start();
                    mediaRecorderRef.current = mr;
                    setIsRecording(true);
                }
            };

            const handleSend = () => {
                if(preview) {
                    const name = preview.type === 'image' ? `photo_${Date.now()}.jpg` : `video_${Date.now()}.webm`;
                    const type = preview.type === 'image' ? 'image/jpeg' : 'video/webm';
                    onCapture(preview.blob, name, type);
                    onClose();
                }
            };

            const retake = () => {
                setPreview(null);
            };

            return (
                <div className="fixed inset-0 z-[60] bg-black flex flex-col app-height">
                    {/* Header */}
                    <div className="p-4 flex justify-between items-center bg-black/50 absolute top-0 w-full z-10 pb-safe">
                        <button onClick={onClose} className="text-white bg-white/10 p-2 rounded-full"><Icon name="x" /></button>
                        {isRecording && <div className="text-red-500 font-mono font-bold animate-pulse">REC {formatTime(timer)}</div>}
                        <div className="w-8"></div>
                    </div>

                    {/* Main View */}
                    <div className="flex-1 relative bg-black flex items-center justify-center overflow-hidden">
                        {!preview ? (
                            <>
                                <video ref={videoRef} className="absolute inset-0 w-full h-full object-cover" muted playsInline></video>
                                <canvas ref={canvasRef} className="hidden"></canvas>
                                {/* Crosshair */}
                                <div className="absolute inset-0 pointer-events-none flex items-center justify-center opacity-30">
                                    <div className="w-64 h-64 border border-white/50 rounded-lg"></div>
                                    <div className="w-2 h-2 bg-white/80 rounded-full"></div>
                                </div>
                            </>
                        ) : (
                            <div className="relative w-full h-full bg-black flex items-center justify-center">
                                {preview.type === 'image' ? 
                                    <img src={preview.url} className="max-w-full max-h-full" alt="preview" /> : 
                                    <video src={preview.url} controls className="max-w-full max-h-full" />
                                }
                            </div>
                        )}
                    </div>

                    {/* Controls */}
                    <div className="h-32 bg-black/80 flex items-center justify-around pb-safe">
                        {!preview ? (
                            <>
                                <div className="flex gap-4">
                                    <button onClick={() => setMode('PHOTO')} className={`text-sm font-bold ${mode === 'PHOTO' ? 'text-yellow-400' : 'text-gray-500'}`}>PHOTO</button>
                                    <button onClick={() => setMode('VIDEO')} className={`text-sm font-bold ${mode === 'VIDEO' ? 'text-yellow-400' : 'text-gray-500'}`}>VIDEO</button>
                                </div>
                                <button 
                                    onClick={mode === 'PHOTO' ? takePhoto : toggleVideo}
                                    className={`w-16 h-16 rounded-full border-4 border-white flex items-center justify-center transition-all ${isRecording ? 'bg-red-500 scale-110' : 'bg-transparent active:scale-95'}`}
                                >
                                    <div className={`rounded-full ${mode === 'PHOTO' ? 'bg-white w-12 h-12' : 'bg-red-500 w-10 h-10'}`}></div>
                                </button>
                                <div className="w-12"></div> {/* Spacer */}
                            </>
                        ) : (
                            <div className="flex w-full justify-around items-center">
                                <button onClick={retake} className="text-white font-bold">Retake</button>
                                <button onClick={handleSend} className="bg-cyan-500 text-black px-8 py-3 rounded-full font-bold text-lg">Send</button>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        // --- MAIN APP ---
        const App = () => {
            const [view, setView] = useState('HOME');
            const [role, setRole] = useState(null);
            const [logs, setLogs] = useState([]);
            const [msgText, setMsgText] = useState("");
            const [messages, setMessages] = useState([]);
            const [showVerify, setShowVerify] = useState(false);
            const [fileProgress, setFileProgress] = useState(0); 
            const [showCamera, setShowCamera] = useState(false);
            
            // Audio Recording State
            const [isRecordingAudio, setIsRecordingAudio] = useState(false);
            const [audioTimer, setAudioTimer] = useState(0);
            const audioRecorderRef = useRef(null);
            const audioChunksRef = useRef([]);

            // WebRTC Refs
            const pc = useRef(null);
            const dc = useRef(null);
            const candidates = useRef([]);
            
            // Crypto Refs
            const keys = useRef({ rsa: null, ecdh: null });
            const sessionKey = useRef(null);
            const fingerprint = useRef(null);
            const incomingFiles = useRef({});
            const fileInputRef = useRef(null);
            const chatEndRef = useRef(null);

            // Signaling State
            const [localSignal, setLocalSignal] = useState(null);
            const scannedChunks = useRef(new Map());
            const [scanProgress, setScanProgress] = useState(0);

            // Call State
            const [callStatus, setCallStatus] = useState('IDLE'); // IDLE, OUTGOING, INCOMING, ACTIVE
            const [localStream, setLocalStream] = useState(null);
            const [remoteStream, setRemoteStream] = useState(null);
            const [isVideoCall, setIsVideoCall] = useState(false);
            const pendingOffer = useRef(null);

            // Initial Key Gen
            useEffect(() => {
                const initKeys = async () => {
                    keys.current.rsa = await window.crypto.subtle.generateKey(
                        { name: "RSA-OAEP", modulusLength: 2048, publicExponent: new Uint8Array([1, 0, 1]), hash: "SHA-256" },
                        true, ["encrypt", "decrypt"]
                    );
                    keys.current.ecdh = await window.crypto.subtle.generateKey(
                        { name: "ECDH", namedCurve: "P-256" },
                        true, ["deriveKey", "deriveBits"]
                    );
                    addLog("Keys Generated.");
                };
                initKeys();
            }, []);

            // Auto-scroll
            useEffect(() => {
                if (chatEndRef.current) chatEndRef.current.scrollIntoView({ behavior: "smooth" });
            }, [messages]);

            // Audio Timer
            useEffect(() => {
                let interval;
                if(isRecordingAudio) {
                    interval = setInterval(() => setAudioTimer(t => t+1), 1000);
                } else {
                    setAudioTimer(0);
                }
                return () => clearInterval(interval);
            }, [isRecordingAudio]);

            const addLog = (txt) => setLogs(p => [...p.slice(-4), txt]);

            // WebRTC Setup
            const createPeer = useCallback(() => {
                const peer = new RTCPeerConnection(ICE_SERVERS);
                
                peer.onicecandidate = (e) => { 
                    if (e.candidate) {
                        // If we have a DC open (post-connection), signal via DC
                        if (dc.current && dc.current.readyState === 'open') {
                             dc.current.send(JSON.stringify({ t: 'SIG_ICE', c: e.candidate }));
                        } else {
                            // Otherwise buffer for QR
                            candidates.current.push(e.candidate); 
                        }
                    } 
                };
                
                peer.onconnectionstatechange = () => addLog(`Connection: ${peer.connectionState}`);
                
                peer.ontrack = (e) => {
                    setRemoteStream(e.streams[0]);
                };

                pc.current = peer;
                return peer;
            }, []);

            const processSignal = useCallback(async (data) => {
                if (!pc.current) return;
                
                if(role === 'HOST' && data.type === 'answer') {
                    await pc.current.setRemoteDescription(new RTCSessionDescription(data.sdp));
                    data.candidates.forEach(c => pc.current.addIceCandidate(new RTCIceCandidate(c)));
                    addLog("Remote Desc Set.");
                } else if (role === 'JOINER' && data.type === 'offer') {
                    await pc.current.setRemoteDescription(new RTCSessionDescription(data.sdp));
                    data.candidates.forEach(c => pc.current.addIceCandidate(new RTCIceCandidate(c)));
                    
                    const answer = await pc.current.createAnswer();
                    await pc.current.setLocalDescription(answer);
                    await new Promise(r => setTimeout(r, 500)); // Gather candidates
                    
                    setLocalSignal({
                        type: 'answer',
                        sdp: pc.current.localDescription,
                        candidates: candidates.current
                    });
                    setView('JOIN_WAIT');
                }
            }, [role]);

            const handleScannedChunk = useCallback((raw) => {
                const parts = raw.split(':');
                if(parts.length < 4) return;
                const idx = parseInt(parts[1]);
                const total = parseInt(parts[2]);
                const data = parts.slice(3).join(':');

                if(!scannedChunks.current.has(idx)) {
                    scannedChunks.current.set(idx, data);
                    setScanProgress(Math.round((scannedChunks.current.size / total) * 100));
                    
                    if(scannedChunks.current.size === total) {
                        const fullB64 = Array.from({length: total}, (_, i) => scannedChunks.current.get(i)).join('');
                        try {
                            const jsonStr = atob(fullB64);
                            const signalData = JSON.parse(jsonStr);
                            addLog("Signal Captured.");
                            scannedChunks.current.clear();
                            processSignal(signalData);
                        } catch(e) {
                            console.error("Signal parse error", e);
                            addLog("Error Parsing Signal");
                        }
                    }
                }
            }, [processSignal]);

            const startHost = async () => {
                setRole('HOST');
                const peer = createPeer();
                dc.current = peer.createDataChannel("shadowlink");
                setupDataChannel(dc.current);
                const offer = await peer.createOffer();
                await peer.setLocalDescription(offer);
                await new Promise(r => setTimeout(r, 500));
                setLocalSignal({ type: 'offer', sdp: peer.localDescription, candidates: candidates.current });
                setView('HOST_WAIT');
            };

            const startJoin = () => {
                setRole('JOINER');
                const peer = createPeer();
                peer.ondatachannel = (e) => {
                    dc.current = e.channel;
                    setupDataChannel(dc.current);
                };
                setView('SCAN_HOST');
            };

            const setupDataChannel = (channel) => {
                channel.onopen = () => {
                    addLog("Tunnel Open.");
                    initiateSecureHandshake();
                };
                channel.onmessage = async (e) => handlePacket(e.data);
            };

            const initiateSecureHandshake = async () => {
                const rsaPub = await window.crypto.subtle.exportKey("spki", keys.current.rsa.publicKey);
                const ecdhPub = await window.crypto.subtle.exportKey("raw", keys.current.ecdh.publicKey);
                dc.current.send(JSON.stringify({ t: 'HELLO', rsa: buf2hex(rsaPub), ecdh: buf2hex(ecdhPub) }));
            };

            const deriveSession = async (p) => {
                const peerRsa = await window.crypto.subtle.importKey("spki", hex2buf(p.rsa), { name: "RSA-OAEP", hash: "SHA-256" }, true, ["encrypt"]);
                const peerEcdh = await window.crypto.subtle.importKey("raw", hex2buf(p.ecdh), { name: "ECDH", namedCurve: "P-256" }, true, []);
                const sharedBits = await window.crypto.subtle.deriveBits({ name: "ECDH", public: peerEcdh }, keys.current.ecdh.privateKey, 256);
                const hkdfKey = await window.crypto.subtle.importKey("raw", sharedBits, { name: "HKDF" }, false, ["deriveKey"]);
                sessionKey.current = await window.crypto.subtle.deriveKey(
                    { name: "HKDF", hash: "SHA-256", salt: new Uint8Array(), info: new TextEncoder().encode("ShadowLink") },
                    hkdfKey, { name: "AES-GCM", length: 256 }, false, ["encrypt", "decrypt"]
                );

                const fpHash = await window.crypto.subtle.digest("SHA-256", sharedBits);
                const fpArr = new Uint8Array(fpHash);
                const emojis = ["üíÄ","üëΩ","ü§ñ","üëª","ü§°","üëπ","üë∫","üëæ","üéÉ","üêâ","ü¶Ñ","ü¶â","üï∏","‚ö°","üî•","‚ùÑÔ∏è"];
                let fpEmoji = "";
                for(let i=0; i<4; i++) fpEmoji += emojis[fpArr[i] % emojis.length];
                const fpHex = buf2hex(fpHash).substring(0, 8).toUpperCase();
                fingerprint.current = { emoji: fpEmoji, hex: fpHex };
                
                addLog(`Secured: ${fpEmoji}`);
                setView('CHAT');
                setMessages(prev => [...prev, { id: Date.now(), type: 'SYS', text: `SECURE CHANNEL ESTABLISHED` }]);
            };

            const handlePacket = async (raw) => {
                try {
                    const p = JSON.parse(raw);
                    
                    if (p.t === 'HELLO') {
                        await deriveSession(p);
                    } 
                    else if (p.t === 'ENC') {
                        const pt = await decryptData(p.iv, p.d);
                        const text = new TextDecoder().decode(pt);
                        setMessages(prev => [...prev, { id: Date.now(), type: 'RX', text: text }]);
                    }
                    else if (p.t === 'SIG_OFFER') {
                        pendingOffer.current = p.sdp;
                        setIsVideoCall(p.video);
                        setCallStatus('INCOMING');
                    }
                    else if (p.t === 'SIG_ANSWER') {
                        await pc.current.setRemoteDescription(new RTCSessionDescription(p.sdp));
                        setCallStatus('ACTIVE');
                    }
                    else if (p.t === 'SIG_ICE') {
                        await pc.current.addIceCandidate(new RTCIceCandidate(p.c));
                    }
                    else if (p.t === 'CALL_END') {
                        endCallCleanup();
                    }
                    else if (p.t === 'FILE_HEADER') {
                        const pt = await decryptData(p.iv, p.meta);
                        const meta = JSON.parse(new TextDecoder().decode(pt));
                        incomingFiles.current[p.id] = { meta, chunks: [], receivedSize: 0, startTime: Date.now() };
                        setMessages(prev => [...prev, { id: Date.now(), type: 'SYS', text: `Receiving ${meta.name}...` }]);
                    }
                    else if (p.t === 'FILE_CHUNK') {
                        const fileCtx = incomingFiles.current[p.id];
                        if (fileCtx) {
                            const chunkData = base64ToArrayBuffer(p.d);
                            fileCtx.chunks.push({ idx: p.idx, data: chunkData });
                            fileCtx.receivedSize += chunkData.byteLength;
                            
                            if (fileCtx.receivedSize >= fileCtx.meta.encSize) {
                                fileCtx.chunks.sort((a,b) => a.idx - b.idx);
                                const totalLen = fileCtx.chunks.reduce((acc, c) => acc + c.data.byteLength, 0);
                                const cipherBuffer = new Uint8Array(totalLen);
                                let offset = 0;
                                fileCtx.chunks.forEach(c => {
                                    cipherBuffer.set(new Uint8Array(c.data), offset);
                                    offset += c.data.byteLength;
                                });

                                try {
                                    const fileData = await window.crypto.subtle.decrypt(
                                        { name: "AES-GCM", iv: hex2buf(fileCtx.meta.iv) },
                                        sessionKey.current,
                                        cipherBuffer
                                    );
                                    
                                    const blob = new Blob([fileData], { type: fileCtx.meta.type });
                                    const url = URL.createObjectURL(blob);
                                    
                                    setMessages(prev => [...prev, { 
                                        id: Date.now(), 
                                        type: 'FILE', 
                                        text: fileCtx.meta.name,
                                        fileUrl: url,
                                        fileSize: fileCtx.meta.size,
                                        mimeType: fileCtx.meta.type
                                    }]);
                                    delete incomingFiles.current[p.id];
                                } catch(e) {
                                    console.error("Decrypt Fail", e);
                                    setMessages(prev => [...prev, { id: Date.now(), type: 'SYS', text: `Decryption Failed` }]);
                                }
                            }
                        }
                    }
                } catch(e) { console.error("Packet Error", e); }
            };

            const decryptData = async (ivHex, dataHex) => {
                return await window.crypto.subtle.decrypt(
                    { name: "AES-GCM", iv: hex2buf(ivHex) },
                    sessionKey.current,
                    hex2buf(dataHex)
                );
            };

            const sendMessage = async () => {
                if(!msgText.trim() || !sessionKey.current) return;
                const txt = msgText;
                setMsgText("");
                setMessages(prev => [...prev, { id: Date.now(), type: 'TX', text: txt }]);
                const iv = window.crypto.getRandomValues(new Uint8Array(12));
                const enc = await window.crypto.subtle.encrypt(
                    { name: "AES-GCM", iv: iv },
                    sessionKey.current,
                    new TextEncoder().encode(txt)
                );
                dc.current.send(JSON.stringify({ t: 'ENC', iv: buf2hex(iv), d: buf2hex(enc) }));
            };

            const processAndSendFile = async (blob, fileName, fileType) => {
                 if (!sessionKey.current) return;
                
                // 1. Read
                const buffer = await blob.arrayBuffer();
                
                // 2. Encrypt File
                const fileIv = window.crypto.getRandomValues(new Uint8Array(12));
                const encryptedFile = await window.crypto.subtle.encrypt(
                    { name: "AES-GCM", iv: fileIv },
                    sessionKey.current,
                    buffer
                );
                
                // 3. Encrypt Metadata
                const fileId = crypto.randomUUID();
                const metaRaw = JSON.stringify({ name: fileName, size: blob.size, type: fileType, iv: buf2hex(fileIv), encSize: encryptedFile.byteLength });
                const metaIv = window.crypto.getRandomValues(new Uint8Array(12));
                const encMeta = await window.crypto.subtle.encrypt(
                    { name: "AES-GCM", iv: metaIv },
                    sessionKey.current,
                    new TextEncoder().encode(metaRaw)
                );

                // 4. Send Header
                dc.current.send(JSON.stringify({
                    t: 'FILE_HEADER',
                    id: fileId,
                    iv: buf2hex(metaIv),
                    meta: buf2hex(encMeta)
                }));
                
                setMessages(prev => [...prev, { id: Date.now(), type: 'SYS', text: `Sending ${fileName}...` }]);

                // 5. Send Chunks
                const totalChunks = Math.ceil(encryptedFile.byteLength / FILE_CHUNK_SIZE);
                let offset = 0;
                
                for (let i = 0; i < totalChunks; i++) {
                    const chunk = encryptedFile.slice(offset, offset + FILE_CHUNK_SIZE);
                    const b64Chunk = arrayBufferToBase64(chunk);
                    if (i % 10 === 0) await new Promise(r => setTimeout(r, 10)); // Flow control
                    dc.current.send(JSON.stringify({ t: 'FILE_CHUNK', id: fileId, idx: i, d: b64Chunk }));
                    offset += FILE_CHUNK_SIZE;
                    setFileProgress(Math.round(((i + 1) / totalChunks) * 100));
                }

                setFileProgress(0);
                
                // Create local preview blob for sender
                const localUrl = URL.createObjectURL(blob);
                setMessages(prev => [...prev, { 
                    id: Date.now(), 
                    type: 'TX_FILE', 
                    text: fileName, 
                    fileUrl: localUrl,
                    mimeType: fileType
                }]);
            };

            const handleFileSelect = (e) => {
                const file = e.target.files[0];
                if (file) processAndSendFile(file, file.name, file.type);
            };

            // --- CALLING LOGIC ---
            const startCall = async (video = false) => {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: video });
                    setLocalStream(stream);
                    setIsVideoCall(video);
                    
                    stream.getTracks().forEach(track => pc.current.addTrack(track, stream));
                    
                    const offer = await pc.current.createOffer();
                    await pc.current.setLocalDescription(offer);
                    
                    dc.current.send(JSON.stringify({ t: 'SIG_OFFER', sdp: offer, video }));
                    setCallStatus('OUTGOING');
                } catch(e) {
                    console.error("Call Error", e);
                    alert("Could not access camera/microphone");
                }
            };

            const answerCall = async () => {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: isVideoCall });
                    setLocalStream(stream);
                    
                    stream.getTracks().forEach(track => pc.current.addTrack(track, stream));
                    
                    await pc.current.setRemoteDescription(new RTCSessionDescription(pendingOffer.current));
                    const answer = await pc.current.createAnswer();
                    await pc.current.setLocalDescription(answer);
                    
                    dc.current.send(JSON.stringify({ t: 'SIG_ANSWER', sdp: answer }));
                    setCallStatus('ACTIVE');
                } catch(e) {
                    console.error("Answer Error", e);
                }
            };

            const endCall = () => {
                dc.current.send(JSON.stringify({ t: 'CALL_END' }));
                endCallCleanup();
            };

            const endCallCleanup = () => {
                if(localStream) {
                    localStream.getTracks().forEach(t => t.stop());
                    setLocalStream(null);
                }
                setRemoteStream(null);
                setCallStatus('IDLE');
                
                // Remove media tracks from PeerConnection to reset state for next call
                // Note: Simply replacing track is complex in simple P2P, often easier to reload or renegotiate properly. 
                // For this demo, we rely on stopping local stream.
            };

            // --- MEDIA HANDLING ---

            const startAudioRecord = async () => {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    const recorder = new MediaRecorder(stream);
                    audioChunksRef.current = [];
                    
                    recorder.ondataavailable = e => audioChunksRef.current.push(e.data);
                    recorder.onstop = () => {
                        const blob = new Blob(audioChunksRef.current, { type: 'audio/webm' });
                        processAndSendFile(blob, `voice_${Date.now()}.webm`, 'audio/webm');
                        stream.getTracks().forEach(t => t.stop());
                    };
                    
                    recorder.start();
                    audioRecorderRef.current = recorder;
                    setIsRecordingAudio(true);
                } catch(e) { console.error("Mic Error", e); }
            };

            const stopAudioRecord = () => {
                if(audioRecorderRef.current && isRecordingAudio) {
                    audioRecorderRef.current.stop();
                    setIsRecordingAudio(false);
                }
            };

            // Render Message Content
            const renderMediaContent = (m) => {
                const type = m.mimeType || '';
                
                if (type.startsWith('image/')) {
                    return <img src={m.fileUrl} className="rounded-lg max-w-full h-auto mt-2 border border-slate-700" alt="content" />;
                } 
                else if (type.startsWith('video/')) {
                    return <video src={m.fileUrl} controls className="rounded-lg max-w-full h-auto mt-2 border border-slate-700" />;
                } 
                else if (type.startsWith('audio/')) {
                    return <div className="mt-2 w-full min-w-[200px]">
                        <audio src={m.fileUrl} controls className="w-full h-8" />
                    </div>;
                }
                
                // Default File Download
                return (
                    <a href={m.fileUrl} download={m.text} className="mt-2 flex items-center justify-center gap-2 w-full py-2 bg-slate-700 hover:bg-slate-600 text-white rounded-lg text-xs font-bold transition-colors">
                        <Icon name="download" size={14} /> Download File
                    </a>
                );
            };

            // Render Views
            const renderHome = () => (
                <div className="flex flex-col items-center justify-center app-height p-6 space-y-8 animate-fade-in">
                    <div className="text-center space-y-2">
                        <div className="relative inline-block">
                            <Icon name="ghost" size={64} className="text-cyan-400 mx-auto" />
                            <div className="absolute top-0 right-0 w-3 h-3 bg-purple-500 rounded-full animate-ping"></div>
                        </div>
                        <h1 className="text-4xl font-bold tracking-tighter text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-purple-500">
                            ShadowLink
                        </h1>
                        <p className="text-slate-400 text-sm font-mono">Zero-Knowledge Kinetic Mesh</p>
                    </div>
                    <div className="grid grid-cols-1 gap-4 w-full max-w-xs">
                        <button onClick={startHost} className="group relative overflow-hidden p-6 rounded-2xl bg-slate-800 border border-slate-700 hover:border-cyan-500 transition-all text-left">
                            <div className="absolute top-0 left-0 w-1 h-full bg-cyan-500 group-hover:w-full transition-all duration-300 opacity-20"></div>
                            <h3 className="text-xl font-bold text-white flex items-center gap-2">
                                <Icon name="radio-tower" size={20} /> Host Room
                            </h3>
                            <p className="text-xs text-slate-400 mt-1">Create a secure signal.</p>
                        </button>
                        <button onClick={startJoin} className="group relative overflow-hidden p-6 rounded-2xl bg-slate-800 border border-slate-700 hover:border-purple-500 transition-all text-left">
                            <div className="absolute top-0 left-0 w-1 h-full bg-purple-500 group-hover:w-full transition-all duration-300 opacity-20"></div>
                            <h3 className="text-xl font-bold text-white flex items-center gap-2">
                                <Icon name="scan-line" size={20} /> Join Room
                            </h3>
                            <p className="text-xs text-slate-400 mt-1">Scan a signal to connect.</p>
                        </button>
                    </div>
                </div>
            );

            const renderSignaling = () => {
                const isScanner = view === 'SCAN_HOST' || view === 'SCAN_JOIN';
                const isQR = view === 'HOST_WAIT' || view === 'JOIN_WAIT';
                const title = view === 'HOST_WAIT' ? "Host Signal" : view === 'SCAN_HOST' ? "Scan Host" : view === 'SCAN_JOIN' ? "Scan Reply" : "Your Reply";

                return (
                    <div className="flex flex-col app-height p-4 items-center justify-center space-y-6 fade-in">
                        <div className="w-full max-w-md glass-panel rounded-3xl p-6 relative">
                            <button onClick={() => window.location.reload()} className="absolute top-4 left-4 p-2 bg-slate-800 rounded-full hover:bg-red-500/20 text-slate-400 hover:text-red-400 transition-all">
                                <Icon name="x" size={16} />
                            </button>
                            <div className="text-center mb-6">
                                <h2 className="text-2xl font-bold text-white mb-1">{title}</h2>
                                <p className="text-xs text-cyan-400 font-mono">
                                    {isScanner ? "Point camera at peer's screen" : "Show this to peer"}
                                </p>
                            </div>
                            <div className="flex justify-center min-h-[250px] items-center">
                                {isQR && localSignal && (
                                    <div className="space-y-4 w-full">
                                        <QRAnimator data={localSignal} label="Signal Packet" />
                                        {view === 'HOST_WAIT' && (
                                            <button onClick={() => setView('SCAN_JOIN')} className="w-full py-4 bg-gradient-to-r from-purple-600 to-indigo-600 rounded-xl font-bold shadow-lg shadow-purple-900/40 flex items-center justify-center gap-2">
                                                <Icon name="scan-eye" /> I've been Scanned
                                            </button>
                                        )}
                                    </div>
                                )}
                                {isScanner && (
                                    <div className="w-full space-y-4">
                                        <QRScanner onScan={handleScannedChunk} />
                                        {scanProgress > 0 && scanProgress < 100 && (
                                            <div className="w-full bg-slate-800 h-2 rounded-full overflow-hidden">
                                                <div className="h-full bg-green-500 transition-all" style={{width: `${scanProgress}%`}}></div>
                                            </div>
                                        )}
                                    </div>
                                )}
                            </div>
                        </div>
                        <div className="font-mono text-[10px] text-slate-500 bg-black/50 px-4 py-2 rounded-lg">
                            {logs[logs.length-1] || "Initializing..."}
                        </div>
                    </div>
                );
            };

            const renderChat = () => (
                <div className="app-height bg-[#0b141a] overflow-hidden">
                    <header className="px-4 py-3 bg-[#1f2c34] flex items-center justify-between shadow-md z-10 shrink-0">
                        <div className="flex items-center gap-3 cursor-pointer" onClick={() => setShowVerify(true)}>
                            <div className="w-10 h-10 rounded-full bg-gradient-to-br from-cyan-500 to-blue-600 flex items-center justify-center text-white font-bold text-xl shadow-[0_0_15px_rgba(6,182,212,0.5)]">
                                {fingerprint.current?.emoji.substring(0,2)}
                            </div>
                            <div>
                                <h2 className="font-bold text-slate-100 text-sm">Secure Peer</h2>
                                <p className="text-[10px] text-emerald-400 font-mono tracking-wider flex items-center gap-1">
                                    <Icon name="lock" size={10} /> AES-GCM-256
                                </p>
                            </div>
                        </div>
                        <div className="flex gap-2">
                            <button onClick={() => startCall(false)} className="p-2 text-slate-400 hover:text-green-400 bg-slate-800 rounded-full">
                                <Icon name="phone" size={18} />
                            </button>
                            <button onClick={() => startCall(true)} className="p-2 text-slate-400 hover:text-cyan-400 bg-slate-800 rounded-full">
                                <Icon name="video" size={18} />
                            </button>
                            <button onClick={() => window.location.reload()} className="p-2 text-slate-400 hover:text-red-400">
                                <Icon name="log-out" size={20} />
                            </button>
                        </div>
                    </header>

                    <div className="flex-1 overflow-y-auto p-4 space-y-3 bg-[url('https://www.transparenttextures.com/patterns/carbon-fibre.png')]">
                        {messages.map((m) => (
                            m.type === 'SYS' ? (
                                <div key={m.id} className="msg-sys"><span className="sys-pill">{m.text}</span></div>
                            ) : (
                                <div key={m.id} className={`flex ${['TX', 'TX_FILE'].includes(m.type) ? 'justify-end' : 'justify-start'}`}>
                                    <div className={`msg-bubble ${['TX', 'TX_FILE'].includes(m.type) ? 'msg-me' : 'msg-other'} shadow-sm text-sm ${['FILE', 'TX_FILE'].includes(m.type) ? 'min-w-[200px]' : ''}`}>
                                        {['FILE', 'TX_FILE'].includes(m.type) ? (
                                            <>
                                                <div className="flex items-center gap-2 mb-1">
                                                    <Icon name={m.mimeType?.startsWith('image') ? 'image' : m.mimeType?.startsWith('video') ? 'video' : m.mimeType?.startsWith('audio') ? 'mic' : 'file'} size={16} className="opacity-70" />
                                                    <span className="font-bold text-xs opacity-90 truncate max-w-[150px]">{m.text}</span>
                                                </div>
                                                {renderMediaContent(m)}
                                            </>
                                        ) : (
                                            m.text
                                        )}
                                        <div className="text-[9px] mt-1 opacity-60 text-right font-mono">
                                            {new Date(m.id).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'})}
                                        </div>
                                    </div>
                                </div>
                            )
                        ))}
                        <div ref={chatEndRef}></div>
                    </div>

                    {fileProgress > 0 && (
                        <div className="h-1 bg-slate-800 w-full shrink-0">
                            <div className="h-full bg-purple-500 transition-all duration-100" style={{width: `${fileProgress}%`}}></div>
                        </div>
                    )}

                    <div className="p-2 bg-[#1f2c34] flex items-center gap-2 shrink-0 pb-safe">
                        {!isRecordingAudio ? (
                            <>
                                <input type="file" ref={fileInputRef} className="hidden" onChange={handleFileSelect} />
                                <button onClick={() => fileInputRef.current?.click()} className="p-3 rounded-full text-slate-400 hover:bg-white/5 transition-colors">
                                    <Icon name="paperclip" size={20} />
                                </button>
                                <button onClick={() => setShowCamera(true)} className="p-3 rounded-full text-slate-400 hover:bg-white/5 transition-colors">
                                    <Icon name="camera" size={20} />
                                </button>
                                <div className="flex-1 bg-[#2a3942] rounded-2xl flex items-center px-4 py-2">
                                    <input 
                                        value={msgText}
                                        onChange={e => setMsgText(e.target.value)}
                                        onKeyDown={e => e.key === 'Enter' && sendMessage()}
                                        type="text" placeholder="Message" className="bg-transparent border-none outline-none text-slate-200 w-full placeholder-slate-500 text-sm"
                                    />
                                </div>
                                {msgText ? (
                                    <button onClick={sendMessage} className="p-3 rounded-full bg-cyan-600 text-white shadow-[0_0_15px_rgba(8,145,178,0.4)]">
                                        <Icon name="send-horizontal" size={20} />
                                    </button>
                                ) : (
                                    <button onClick={startAudioRecord} className="p-3 rounded-full bg-[#2a3942] text-slate-400 hover:text-red-400 transition-colors">
                                        <Icon name="mic" size={20} />
                                    </button>
                                )}
                            </>
                        ) : (
                            <div className="flex-1 flex items-center gap-4 bg-[#2a3942] rounded-2xl p-2 px-4 animate-pulse border border-red-500/30">
                                <div className="w-3 h-3 bg-red-500 rounded-full animate-ping"></div>
                                <span className="text-red-400 font-mono font-bold flex-1">Recording {formatTime(audioTimer)}</span>
                                <button onClick={() => setIsRecordingAudio(false)} className="text-slate-400 text-xs uppercase font-bold px-2">Cancel</button>
                                <button onClick={stopAudioRecord} className="p-2 bg-red-500 rounded-full text-white shadow-lg pulse-ring">
                                    <Icon name="send-horizontal" size={18} />
                                </button>
                            </div>
                        )}
                    </div>

                    {showVerify && fingerprint.current && (
                        <IdentityModal fingerprint={fingerprint.current} onClose={() => setShowVerify(false)} />
                    )}

                    {showCamera && (
                        <CameraModal onClose={() => setShowCamera(false)} onCapture={processAndSendFile} />
                    )}

                    {callStatus !== 'IDLE' && (
                        <CallOverlay 
                            status={callStatus} 
                            localStream={localStream} 
                            remoteStream={remoteStream} 
                            isVideo={isVideoCall}
                            onAnswer={answerCall}
                            onHangup={endCall}
                        />
                    )}
                </div>
            );

            if(view === 'HOME') return renderHome();
            if(view === 'CHAT') return renderChat();
            return renderSignaling();
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
