<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üîä Gibberlink Text Messenger (Fixed)</title>
    <style>
        :root {
            --bg: #f5f5f5;
            --chat-bg: white;
            --text: #333;
            --sent-bg: #007bff;
            --recv-bg: #e9ecef;
            --btn-bg: #28a745;
            --btn-hover: #218838;
            --status: #666;
        }
        [data-theme="dark"] {
            --bg: #121212;
            --chat-bg: #1e1e1e;
            --text: #eee;
            --sent-bg: #0056b3;
            --recv-bg: #2d2d2d;
            --btn-bg: #28a745;
            --btn-hover: #218838;
            --status: #aaa;
        }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, sans-serif; 
            max-width: 600px; margin: 0 auto; padding: 20px; 
            background: var(--bg); color: var(--text); transition: background 0.3s; 
        }
        .chat-log { 
            background: var(--chat-bg); border-radius: 10px; padding: 15px; 
            height: 300px; overflow-y: auto; margin-bottom: 20px; 
            box-shadow: 0 2px 10px rgba(0,0,0,0.1); 
        }
        .message { 
            margin: 10px 0; padding: 12px 16px; border-radius: 18px; 
            max-width: 80%; position: relative; animation: fadeIn 0.3s; 
        }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        .sent { background: var(--sent-bg); color: white; margin-left: auto; text-align: right; }
        .received { background: var(--recv-bg); color: var(--text); }
        .timestamp { font-size: 0.75em; opacity: 0.7; margin-top: 4px; }
        #inputMsg { 
            width: 60%; padding: 12px; border: 1px solid #ddd; border-radius: 20px; 
            background: var(--chat-bg); color: var(--text); 
        }
        button { 
            padding: 12px 16px; background: var(--btn-bg); color: white; border: none; 
            border-radius: 20px; cursor: pointer; margin: 0 5px; font-size: 16px; 
            touch-action: manipulation; transition: background 0.2s; 
        }
        button:hover { background: var(--btn-hover); }
        button:disabled { background: #6c757d; cursor: not-allowed; }
        .spinner { display: inline-block; width: 20px; height: 20px; border: 3px solid rgba(255,255,255,.3); border-radius: 50%; border-top-color: white; animation: spin 1s ease-in-out infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
        #status { font-size: 14px; color: var(--status); margin: 10px 0; text-align: center; }
        .controls { display: flex; flex-wrap: wrap; justify-content: space-between; align-items: center; margin-bottom: 20px; gap: 10px; }
        .theme-toggle { background: #6c757d; }
        .theme-toggle:hover { background: #5a6268; }
        h1 { text-align: center; color: var(--text); margin-bottom: 10px; }
        .actions { display: flex; gap: 10px; flex-wrap: wrap; }
        #debug { font-size: 12px; color: #999; margin-top: 10px; }
    </style>
</head>
<body data-theme="light">
    <h1>üîä Gibberlink Text Messenger (Fixed!)</h1>
    <div id="status">Loading ggwave... Check console (F12) for errors.</div>
    <div id="debug"></div>
    
    <div class="chat-log" id="chatLog" role="log" aria-live="polite">
        <div class="message received">
            <div>Fixed version loaded! Type a message and üì§ send. Receiver: Tap üé§ to listen.</div>
            <div class="timestamp">Just now</div>
        </div>
    </div>
    
    <div class="controls">
        <input type="text" id="inputMsg" placeholder="Type your message (e.g., Hello!)" maxlength="50" aria-label="Message input">
        <div class="actions">
            <button id="sendBtn" onclick="sendMessage()" aria-label="Send message via sound">üì§ Send</button>
            <button id="listenBtn" onclick="toggleListening()" aria-label="Toggle listening">üé§ Listen</button>
            <button onclick="clearChat()" aria-label="Clear chat">üóëÔ∏è Clear</button>
            <button onclick="exportChat()" aria-label="Export chat log">üì• Share</button>
            <button class="theme-toggle" onclick="toggleTheme()" aria-label="Toggle dark mode">üåô</button>
        </div>
    </div>

    <script src="ggwave.js"></script> <!-- Or CDN: https://cdn.jsdelivr.net/npm/ggwave@0.5.4/ggwave.js -->
    <script>
        let ggwaveInstance;
        let audioContext;
        let mediaStream;
        let isListening = false;
        let processor;
        let chatLog = document.getElementById('chatLog');
        let status = document.getElementById('status');
        let debug = document.getElementById('debug');
        let sendBtn = document.getElementById('sendBtn');
        let listenBtn = document.getElementById('listenBtn');
        let notificationPermission = Notification.permission;

        function logDebug(msg) {
            console.log(msg);
            debug.textContent += msg + '\n';
        }

        // Convert Float32 to Int8Array for decode (from official example)
        function convertTypedArray(input, TypedArray) {
            const output = new TypedArray(input.length);
            for (let i = 0; i < input.length; i++) {
                output[i] = Math.max(-1, Math.min(1, input[i])) * 127;
            }
            return output;
        }

        // Init ggwave
        async function initGgwave() {
            if (typeof ggwave === 'undefined') {
                status.textContent = 'Error: ggwave.js not loaded! Check src path.';
                logDebug('ggwave undefined');
                return false;
            }
            try {
                const parameters = ggwave.getDefaultParameters();
                ggwaveInstance = ggwave.init(parameters);
                if (!ggwaveInstance) throw new Error('Init failed');
                status.textContent = 'Ggwave initialized! Ready to chat. üöÄ';
                logDebug('ggwave init success');
                return true;
            } catch (err) {
                status.textContent = `Init error: ${err.message}`;
                logDebug(`Init error: ${err}`);
                return false;
            }
        }

        // Add message
        function addMessage(text, isSent = false) {
            const msg = document.createElement('div');
            msg.className = `message ${isSent ? 'sent' : 'received'}`;
            msg.innerHTML = `<div>${escapeHtml(text)}</div><div class="timestamp">${new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</div>`;
            chatLog.appendChild(msg);
            chatLog.scrollTop = chatLog.scrollHeight;
            if (!isSent) notifyUser(text);
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        async function notifyUser(text) {
            if (notificationPermission === 'granted') {
                new Notification('New Sound Message!', { body: text, icon: 'üîä' });
            } else if (notificationPermission === 'default') {
                notificationPermission = await Notification.requestPermission();
            }
        }

        // Send message
        async function sendMessage() {
            const msg = document.getElementById('inputMsg').value.trim();
            if (!msg) return;
            if (!ggwaveInstance && !(await initGgwave())) return;

            addMessage(msg, true);
            document.getElementById('inputMsg').value = '';
            const originalText = sendBtn.innerHTML;
            sendBtn.innerHTML = '<span class="spinner"></span> Sending...';
            sendBtn.disabled = true;

            try {
                const encoder = new TextEncoder();
                const payloadBytes = encoder.encode(msg).length;
                const waveform = ggwave.encode(ggwaveInstance, msg, ggwave.ProtocolId.GGWAVE_PROTOCOL_AUDIBLE_FAST, payloadBytes);
                if (!waveform || waveform.length === 0) throw new Error('Empty waveform');

                logDebug(`Encoded ${msg} to ${waveform.length} samples`);

                // Convert Uint8 (0-255) to Float32 (-1 to 1) for playback
                const floatSamples = new Float32Array(waveform.length);
                for (let i = 0; i < waveform.length; i++) {
                    floatSamples[i] = (waveform[i] - 128) / 128.0;  // Assume signed 8-bit packed as uint8
                }

                if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const buffer = audioContext.createBuffer(1, floatSamples.length, 48000);
                buffer.copyToChannel(floatSamples, 0);
                const source = audioContext.createBufferSource();
                source.buffer = buffer;
                source.connect(audioContext.destination);
                source.start();
                status.textContent = `Playing sound for "${msg}"... (point mic at speaker) üîä`;

                source.onended = () => {
                    status.textContent = 'Sent! Listen for replies. üì®';
                    sendBtn.innerHTML = originalText;
                    sendBtn.disabled = false;
                };
            } catch (err) {
                status.textContent = `Send error: ${err.message}`;
                logDebug(`Send error: ${err}`);
                sendBtn.innerHTML = originalText;
                sendBtn.disabled = false;
            }
        }

        // Toggle listening
        async function toggleListening() {
            if (isListening) {
                stopListening();
                return;
            }

            if (!ggwaveInstance && !(await initGgwave())) return;

            try {
                mediaStream = await navigator.mediaDevices.getUserMedia({ audio: { sampleRate: 48000 } });
                if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const source = audioContext.createMediaStreamSource(mediaStream);

                // Use ScriptProcessor for compatibility (AudioWorklet better but more code)
                processor = audioContext.createScriptProcessor(4096, 1, 1);
                processor.onaudioprocess = (e) => {
                    const inputBuffer = e.inputBuffer.getChannelData(0);  // Float32Array
                    const int8Data = convertTypedArray(inputBuffer, Int8Array);
                    const decoded = ggwave.decode(ggwaveInstance, int8Data);
                    if (decoded && decoded.length > 0) {
                        const text = new TextDecoder('utf-8').decode(decoded).trim();
                        if (text) {
                            addMessage(text, false);
                            status.textContent = `Decoded: "${text}" üéâ`;
                            logDebug(`Decoded: ${text}`);
                        }
                    }
                };
                source.connect(processor);
                processor.connect(audioContext.destination);  // Optional: echo for testing

                isListening = true;
                listenBtn.innerHTML = '<span class="spinner"></span> Stop';
                status.textContent = 'Listening for sound... (play near mic) üé§';
                logDebug('Listening started');
            } catch (err) {
                status.textContent = `Mic error: ${err.message}. Enable in settings.`;
                logDebug(`Listen error: ${err}`);
            }
        }

        function stopListening() {
            if (mediaStream) {
                mediaStream.getTracks().forEach(track => track.stop());
                mediaStream = null;
            }
            if (processor) {
                processor.disconnect();
                processor = null;
            }
            isListening = false;
            listenBtn.innerHTML = 'üé§ Listen';
            status.textContent = 'Stopped listening. üòä';
            logDebug('Listening stopped');
        }

        function clearChat() {
            if (confirm('Clear chat?')) {
                chatLog.innerHTML = '';
                addMessage('Chat cleared! Start chatting. ‚ú®', false);
            }
        }

        function exportChat() {
            const log = Array.from(chatLog.children).map(msg => msg.textContent).join('\n');
            const blob = new Blob([log], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `gibberlink-chat-${new Date().toISOString().split('T')[0]}.txt`;
            a.click();
            URL.revokeObjectURL(url);
            status.textContent = 'Chat exported! üìÑ';
        }

        function toggleTheme() {
            const body = document.body;
            const isDark = body.dataset.theme === 'dark';
            body.dataset.theme = isDark ? 'light' : 'dark';
            localStorage.setItem('theme', body.dataset.theme);
        }

        // Load & init
        window.addEventListener('load', async () => {
            const savedTheme = localStorage.getItem('theme') || 'light';
            document.body.dataset.theme = savedTheme;
            if ('Notification' in window) notificationPermission = Notification.permission;
            await initGgwave();  // Auto-init
            navigator.mediaDevices.getUserMedia({ audio: true }).catch(() => logDebug('Early perm check failed - grant when prompted'));
            
            // Shortcuts
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && e.ctrlKey) sendMessage();
                if (e.key === 'Escape') stopListening();
            });
        });

        // Enter to send
        document.getElementById('inputMsg').addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) sendMessage();
        });
    </script>
</body>
</html>
