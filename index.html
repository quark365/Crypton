<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CryptoVis: RSA+AES Hybrid Security</title>
    
    <!-- React & Tailwind -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- QR Libs -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrious/4.0.2/qrious.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap');
        body { font-family: 'JetBrains Mono', monospace; background-color: #0f172a; color: #e2e8f0; }
        .glass { background: rgba(30, 41, 59, 0.95); backdrop-filter: blur(20px); border: 1px solid rgba(148, 163, 184, 0.1); }
        .scan-line { width: 100%; height: 2px; background: #06b6d4; position: absolute; animation: scan 2s linear infinite; box-shadow: 0 0 10px #06b6d4; }
        @keyframes scan { 0% { top: 0%; opacity: 0; } 50% { opacity: 1; } 100% { top: 100%; opacity: 0; } }
        .matrix-bg { background-image: radial-gradient(#1e293b 1px, transparent 1px); background-size: 20px 20px; }
        .pulse-mic { animation: micPulse 1.5s infinite; }
        @keyframes micPulse { 0% { box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.7); } 70% { box-shadow: 0 0 0 15px rgba(16, 185, 129, 0); } 100% { box-shadow: 0 0 0 0 rgba(16, 185, 129, 0); } }
    </style>
</head>
<body class="matrix-bg min-h-screen">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- TURBO PROTOCOL ---
        const PROTOCOL = {
            START_FREQ: 1200, END_FREQ: 5000, BASE_FREQ: 1500, STEP_FREQ: 120,    
            CHAR_DURATION: 0.05,  // Ultra Fast (50ms) for RSA payload
            HEADER_DURATION: 0.4, FFT_SIZE: 2048, THRESHOLD: 25, ACK_FREQ: 600,        
            QR_FRAME_RATE: 100, QR_CHUNK_SIZE: 600
        };

        const Icon = ({ p, size=24, className="" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>{p}</svg>
        );
        const icons = {
            shield: <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z" />,
            key: <><path d="m21 2-9.6 9.6"/><path d="m15.5 7.5 3 3L22 7l-3-3"/><circle cx="7.5" cy="15.5" r="5.5"/></>,
            qr: <><rect x="3" y="3" width="7" height="7"/><rect x="14" y="3" width="7" height="7"/><rect x="14" y="14" width="7" height="7"/><path d="M10 7h4"/><path d="M7 10v4"/><path d="M14 10h4"/></>,
            cam: <><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/><circle cx="12" cy="13" r="4"/></>,
            send: <><line x1="22" y1="2" x2="11" y2="13"/><polygon points="22 2 15 22 11 13 2 9 22 2"/></>,
            sound: <><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"/></>,
            mic: <><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/></>,
            refresh: <><path d="M23 4v6h-6"/><path d="M1 20v-6h6"/><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10"/><path d="M1 14l4.64 4.36A9 9 0 0 0 20.49 15"/></>,
            clip: <path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48" />
        };

        // --- CRYPTO HELPERS ---
        const buf2hex = (buf) => [...new Uint8Array(buf)].map(x => x.toString(16).padStart(2, '0')).join('');
        const hex2buf = (hex) => new Uint8Array(hex.match(/.{1,2}/g).map(byte => parseInt(byte, 16))).buffer;

        const generateFingerprint = async (buffer) => {
            const hash = await window.crypto.subtle.digest('SHA-256', buffer);
            const arr = new Uint8Array(hash);
            const emojis = ["ğŸ¶","ğŸ±","ğŸ­","ğŸ¹","ğŸ°","ğŸ¦Š","ğŸ»","ğŸ¼","ğŸ¨","ğŸ¯","ğŸ¦","ğŸ®","ğŸ·","ğŸ¸","ğŸµ","ğŸ”","ğŸ§","ğŸ¦","ğŸ¤","ğŸ¦†","ğŸ¦…","ğŸ¦‰","ğŸ¦‡","ğŸº","ğŸ—","ğŸ´","ğŸ¦„","ğŸ","ğŸ›","ğŸ¦‹","ğŸŒ","ğŸ","ğŸœ","ğŸ•·","ğŸ•¸","ğŸ¢","ğŸ","ğŸ¦","ğŸ¦‚","ğŸ¦€","ğŸ¦‘","ğŸ™","ğŸ¦","ğŸ ","ğŸŸ","ğŸ¡","ğŸ¬","ğŸ¦ˆ","ğŸ³","ğŸ‹","ğŸŠ","ğŸ†","ğŸ…","ğŸƒ","ğŸ‚","ğŸ„","ğŸª","ğŸ«","ğŸ˜","ğŸ¦","ğŸ¦","ğŸ","ğŸ–","ğŸ","ğŸ","ğŸ‘","ğŸ•","ğŸ©","ğŸˆ","ğŸ“","ğŸ¦ƒ","ğŸ•Š","ğŸ‡","ğŸ","ğŸ€","ğŸ¿","ğŸ¾","ğŸ‰","ğŸ²","ğŸŒµ","ğŸ„","ğŸŒ²","ğŸŒ³","ğŸŒ´"];
            let fp = "";
            for(let i=0; i<4; i++) fp += emojis[arr[i] % emojis.length];
            return fp;
        };

        // --- AUDIO ENGINE ---
        const AudioEngine = {
            ctx: null,
            init: () => {
                if (!AudioEngine.ctx) AudioEngine.ctx = new (window.AudioContext || window.webkitAudioContext)();
                if (AudioEngine.ctx.state === 'suspended') AudioEngine.ctx.resume();
            },
            playSequence: async (textData) => {
                AudioEngine.init();
                const ctx = AudioEngine.ctx;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.type = 'sawtooth';

                // Encode to Hex
                let hexData = "";
                for (let i = 0; i < textData.length; i++) hexData += textData.charCodeAt(i).toString(16).padStart(2, '0');

                const now = ctx.currentTime;
                osc.frequency.setValueAtTime(PROTOCOL.START_FREQ, now);
                gain.gain.setValueAtTime(0.5, now);

                let startTime = now + PROTOCOL.HEADER_DURATION;
                for (let i = 0; i < hexData.length; i++) {
                    const nibble = parseInt(hexData[i], 16);
                    const freq = PROTOCOL.BASE_FREQ + (nibble * PROTOCOL.STEP_FREQ);
                    osc.frequency.setValueAtTime(freq, startTime + (i * PROTOCOL.CHAR_DURATION));
                }

                const endTime = startTime + (hexData.length * PROTOCOL.CHAR_DURATION);
                osc.frequency.setValueAtTime(PROTOCOL.END_FREQ, endTime);
                osc.start(now);
                osc.stop(endTime + 0.1);

                return new Promise(r => setTimeout(r, (endTime + 0.1 - now) * 1000));
            },
            playAck: async () => {
                AudioEngine.init();
                const ctx = AudioEngine.ctx;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.type = 'square';
                
                const now = ctx.currentTime;
                osc.frequency.setValueAtTime(PROTOCOL.ACK_FREQ, now);
                osc.frequency.exponentialRampToValueAtTime(PROTOCOL.ACK_FREQ * 2, now + 0.5);
                gain.gain.setValueAtTime(0.8, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.8);
                
                osc.start(now);
                osc.stop(now + 0.8);
                return new Promise(r => setTimeout(r, 800));
            }
        };

        // --- COMPONENTS ---
        const QRDisplay = ({ data, label }) => {
            const canvasRef = useRef(null);
            useEffect(() => {
                if (canvasRef.current && data) new QRious({ element: canvasRef.current, value: data, size: 220, level: 'L' });
            }, [data]);
            return (
                <div className="bg-white p-4 rounded-2xl flex flex-col items-center shadow-xl">
                    <canvas ref={canvasRef} />
                    <p className="text-black font-bold text-sm mt-2">{label}</p>
                </div>
            );
        };

        const AnimatedQR = ({ chunks, label, onClose }) => {
            const [index, setIndex] = useState(0);
            useEffect(() => {
                if (!chunks || chunks.length === 0) return;
                const interval = setInterval(() => { setIndex(prev => (prev + 1) % chunks.length); }, PROTOCOL.QR_FRAME_RATE);
                return () => clearInterval(interval);
            }, [chunks]);
            return (
                <div className="fixed inset-0 z-50 bg-black/95 flex flex-col items-center justify-center p-4">
                    <div className="bg-white p-4 rounded-2xl flex flex-col items-center shadow-[0_0_50px_rgba(6,182,212,0.5)]">
                        <QRDisplay data={chunks[index]} label={`${label} (${index + 1}/${chunks.length})`} />
                        <div className="w-full bg-gray-200 h-2 mt-4 rounded-full overflow-hidden">
                            <div className="bg-blue-600 h-full transition-all" style={{width: `${((index+1)/chunks.length)*100}%`}}></div>
                        </div>
                    </div>
                    <p className="text-cyan-400 mt-4 font-mono text-sm animate-pulse">Broadcasting File Stream...</p>
                    <button onClick={onClose} className="mt-8 bg-slate-800 px-8 py-3 rounded-full text-white font-bold hover:bg-slate-700">Stop Broadcast</button>
                </div>
            );
        };

        const QRScanner = ({ onScan, onClose, fileProgress }) => {
            const videoRef = useRef(null);
            const canvasRef = useRef(null);
            const [error, setError] = useState("");

            useEffect(() => {
                let stream;
                navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } })
                    .then(s => {
                        stream = s;
                        if (videoRef.current) { videoRef.current.srcObject = s; videoRef.current.play(); requestAnimationFrame(tick); }
                    })
                    .catch(() => setError("Camera Access Denied. Ensure HTTPS."));

                const tick = () => {
                    if (videoRef.current && videoRef.current.readyState === 4) {
                        const cvs = canvasRef.current;
                        const vid = videoRef.current;
                        cvs.width = vid.videoWidth; cvs.height = vid.videoHeight;
                        const ctx = cvs.getContext("2d");
                        ctx.drawImage(vid, 0, 0);
                        const img = ctx.getImageData(0, 0, cvs.width, cvs.height);
                        const code = jsQR(img.data, img.width, img.height);
                        if (code) { onScan(code.data); }
                    }
                    requestAnimationFrame(tick);
                };
                return () => stream?.getTracks().forEach(t => t.stop());
            }, []);

            return (
                <div className="fixed inset-0 z-50 bg-black/95 flex flex-col items-center justify-center p-4">
                    <div className="relative w-full max-w-sm aspect-square bg-slate-900 rounded-2xl overflow-hidden border-2 border-cyan-500 shadow-[0_0_30px_rgba(6,182,212,0.3)]">
                        <video ref={videoRef} className="absolute inset-0 w-full h-full object-cover" playsInline />
                        <canvas ref={canvasRef} className="hidden" />
                        <div className="scan-line"></div>
                        {error && <div className="absolute inset-0 flex items-center justify-center text-red-400 font-bold bg-black/80 text-center p-6">{error}</div>}
                        {fileProgress && (
                            <div className="absolute bottom-0 left-0 right-0 bg-black/80 p-4">
                                <div className="flex justify-between text-xs text-white mb-1">
                                    <span>Downloading File...</span><span>{Math.round(fileProgress)}%</span>
                                </div>
                                <div className="w-full bg-slate-700 h-2 rounded-full overflow-hidden">
                                    <div className="bg-emerald-500 h-full transition-all duration-100" style={{width: `${fileProgress}%`}}></div>
                                </div>
                            </div>
                        )}
                    </div>
                    <button onClick={onClose} className="mt-8 bg-slate-800 text-white px-8 py-3 rounded-full font-bold hover:bg-slate-700 transition-colors">Cancel</button>
                </div>
            );
        };

        const SonicTransceiver = ({ mode, dataToSend, onData, onAck, onClose }) => {
            const [status, setStatus] = useState("Initializing...");
            const [visuals, setVisuals] = useState(new Array(16).fill(0));
            const stateRef = useRef({ stopRequested: false, ackCounter: 0, decoding: false });

            useEffect(() => {
                let ctx, analyzer, stream, raf;
                const start = async () => {
                    try {
                        stream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: true, noiseSuppression: false, autoGainControl: false } });
                        ctx = new (window.AudioContext || window.webkitAudioContext)();
                        const source = ctx.createMediaStreamSource(stream);
                        analyzer = ctx.createAnalyser();
                        analyzer.fftSize = PROTOCOL.FFT_SIZE;
                        analyzer.smoothingTimeConstant = 0.5;
                        source.connect(analyzer);
                        const dataArray = new Uint8Array(analyzer.frequencyBinCount);
                        const binWidth = ctx.sampleRate / analyzer.fftSize;

                        const loop = () => {
                            analyzer.getByteFrequencyData(dataArray);
                            const v = [];
                            for(let i=0; i<16; i++) {
                                const f = PROTOCOL.BASE_FREQ + (i*PROTOCOL.STEP_FREQ);
                                const bin = Math.round(f / binWidth);
                                v.push(((dataArray[bin] + dataArray[bin+1] + dataArray[bin-1])/3/255)*100);
                            }
                            setVisuals(v);

                            if (mode === 'SENDER') {
                                const ackBin = Math.round(PROTOCOL.ACK_FREQ / binWidth);
                                const energy = dataArray[ackBin] + dataArray[ackBin+1] + dataArray[ackBin-1];
                                if (energy > 120) {
                                    stateRef.current.ackCounter++;
                                    if(stateRef.current.ackCounter > 10) { 
                                        stateRef.current.stopRequested = true;
                                        onAck(); 
                                    }
                                } else stateRef.current.ackCounter = 0;
                            }

                            if (mode === 'RECEIVER') {
                                const startBin = Math.round(PROTOCOL.START_FREQ / binWidth);
                                if (dataArray[startBin] > 80 && !stateRef.current.decoding) { 
                                    stateRef.current.decoding = true;
                                    setStatus("Receiving Payload...");
                                    setTimeout(async () => {
                                        setStatus("Sending ACK...");
                                        await AudioEngine.playAck(); 
                                        onData(dataToSend); 
                                    }, 1500);
                                }
                            }
                            raf = requestAnimationFrame(loop);
                        };
                        loop();
                    } catch(e) { setStatus("Mic Error: " + e.message); }
                };
                start();
                
                const senderLoop = async () => {
                    if (mode !== 'SENDER') return;
                    setStatus("Broadcasting Key... Listening for STOP.");
                    while (!stateRef.current.stopRequested) {
                        await AudioEngine.playSequence(dataToSend || "PING");
                        await new Promise(r => setTimeout(r, 400)); 
                    }
                    setStatus("ACK Received! Authenticated.");
                };
                if (mode === 'SENDER') senderLoop();

                return () => {
                    if(stream) stream.getTracks().forEach(t => t.stop());
                    if(ctx) ctx.close();
                    cancelAnimationFrame(raf);
                };
            }, [mode]);

            return (
                <div className="fixed inset-0 z-50 bg-black/95 flex flex-col items-center justify-center p-6">
                    <div className="text-center mb-8">
                        <h2 className="text-2xl font-bold text-white mb-2">{mode === 'SENDER' ? 'Broadcasting...' : 'Listening...'}</h2>
                        <p className="font-mono text-cyan-400">{status}</p>
                    </div>
                    <div className={`flex items-end gap-1 h-32 mb-8 bg-slate-900/50 p-4 rounded-xl border-2 ${mode === 'SENDER' ? 'border-emerald-500 pulse-mic' : 'border-cyan-500'}`}>
                        {visuals.map((v, i) => (
                            <div key={i} className={`w-3 rounded-t transition-all duration-75 ${mode==='SENDER'?'bg-emerald-500':'bg-cyan-500'}`} style={{height: `${Math.max(v, 5)}%`}}></div>
                        ))}
                    </div>
                    <button onClick={onClose} className="mt-8 bg-slate-800 px-8 py-3 rounded-full text-white font-bold hover:bg-slate-700">Cancel</button>
                </div>
            );
        };

        // --- MAIN APP ---
        const App = () => {
            const [isDarth, setIsDarth] = useState(false);
            const [activeTab, setActiveTab] = useState('CONNECT');
            
            const [rsaKeys, setRsaKeys] = useState(null);
            const [myPublicKeyStr, setMyPublicKeyStr] = useState("");
            
            const [sharedKey, setSharedKey] = useState(null); // AES-GCM Key
            const [fingerprint, setFingerprint] = useState("????");
            
            const [scanner, setScanner] = useState(null); 
            const [audioMode, setAudioMode] = useState(null); 
            
            const [chat, setChat] = useState([]);
            const [msg, setMsg] = useState("");
            
            const [fileTransfer, setFileTransfer] = useState(null);
            const [incomingFile, setIncomingFile] = useState({ id: null, chunks: {}, total: 0 });
            
            // Handshake State
            const [partnerKeyStr, setPartnerKeyStr] = useState(null);
            const [handshakePayload, setHandshakePayload] = useState(null);

            const lastProcessedRef = useRef(""); 

            // 1. GENERATE RSA KEYS (Identity)
            const genKeys = async () => {
                const k = await window.crypto.subtle.generateKey(
                    { name: "RSA-OAEP", modulusLength: 2048, publicExponent: new Uint8Array([1, 0, 1]), hash: "SHA-256" },
                    true, ["encrypt", "decrypt"]
                );
                const exp = await window.crypto.subtle.exportKey("spki", k.publicKey);
                const str = btoa(String.fromCharCode(...new Uint8Array(exp)));
                const json = JSON.stringify({ rsa: str });
                
                setRsaKeys(k);
                setMyPublicKeyStr(json);
                setSharedKey(null);
                setFingerprint("????");
                setPartnerKeyStr(null);
                setHandshakePayload(null);
                lastProcessedRef.current = "";
            };
            useEffect(() => { genKeys(); }, []);

            // 2. INITIATE CONNECTION (Hybrid Encryption: AES key wrapped in RSA)
            const initiateHandshake = async () => {
                if (!partnerKeyStr) return;
                // Import Partner RSA Key
                const payload = JSON.parse(partnerKeyStr);
                const ab = Uint8Array.from(atob(payload.rsa), c => c.charCodeAt(0)).buffer;
                const partnerPubKey = await window.crypto.subtle.importKey("spki", ab, { name: "RSA-OAEP", hash: "SHA-256" }, true, ["encrypt"]);

                // Generate Session AES Key
                const aesKey = await window.crypto.subtle.generateKey({ name: "AES-GCM", length: 256 }, true, ["encrypt", "decrypt"]);
                
                // Export AES Key to raw bytes
                const rawAes = await window.crypto.subtle.exportKey("raw", aesKey);
                
                // Encrypt AES Key with Partner's RSA Public Key
                const encryptedAes = await window.crypto.subtle.encrypt({ name: "RSA-OAEP" }, partnerPubKey, rawAes);
                
                // Packet to send
                const sessionStr = JSON.stringify({ s: btoa(String.fromCharCode(...new Uint8Array(encryptedAes))) });
                
                // Set Local State
                const fp = await generateFingerprint(rawAes);
                setSharedKey(aesKey);
                setFingerprint(fp);
                setHandshakePayload(sessionStr); 
                
                // Start sending this payload
                setAudioMode('SENDER'); 
            };

            // 3. HANDLE DATA (Scanning/Listening)
            const handleData = async (dataStr) => {
                if (dataStr === lastProcessedRef.current) return;
                lastProcessedRef.current = dataStr;

                // Priority Check: File Chunks (Prevents JSON Parse Lag on rapid stream)
                if (dataStr.startsWith('F|')) {
                    if (!sharedKey) return; 
                    const [_, id, idx, tot, payload] = dataStr.split('|');
                    setIncomingFile(prev => {
                        if (prev.id !== id) return { id, chunks: {[parseInt(idx)]: payload}, total: parseInt(tot) };
                        return { ...prev, chunks: { ...prev.chunks, [parseInt(idx)]: payload }, total: parseInt(tot) };
                    });
                    return;
                }

                try {
                    const json = JSON.parse(dataStr);

                    // CASE A: Received Public Key (Identity)
                    if (json.rsa) {
                        setPartnerKeyStr(dataStr);
                        if (confirm("Partner Identity Found. Initiate Secure Handshake?")) {
                            setScanner(null);
                        }
                        return;
                    }

                    // CASE B: Received Encrypted Session Key (Handshake)
                    if (json.s) {
                        const encryptedBytes = Uint8Array.from(atob(json.s), c => c.charCodeAt(0)).buffer;
                        const decryptedRaw = await window.crypto.subtle.decrypt({ name: "RSA-OAEP" }, rsaKeys.privateKey, encryptedBytes);
                        
                        const aesKey = await window.crypto.subtle.importKey("raw", decryptedRaw, { name: "AES-GCM" }, true, ["encrypt", "decrypt"]);
                        const fp = await generateFingerprint(decryptedRaw);
                        
                        setSharedKey(aesKey);
                        setFingerprint(fp);
                        setActiveTab('VERIFY');
                        setScanner(null);
                        setAudioMode(null);
                        alert("Secure Handshake Complete! (RSA Decryption Successful)");
                        return;
                    }

                    // CASE C: Encrypted Message
                    if (json.iv && sharedKey) {
                        const dec = await window.crypto.subtle.decrypt({name:"AES-GCM", iv:hex2buf(json.iv)}, sharedKey, hex2buf(json.d));
                        const txt = new TextDecoder().decode(dec);
                        setChat(prev => [...prev, {from:'Partner', text:txt}]);
                        setScanner(null);
                        setAudioMode(null);
                        alert("Received: " + txt);
                    }

                } catch (e) {
                    // Ignore malformed data
                }
            };

            // File Assembly
            useEffect(() => {
                if (incomingFile.total > 0 && Object.keys(incomingFile.chunks).length === incomingFile.total) {
                    const ordered = [];
                    for(let i=0; i<incomingFile.total; i++) ordered.push(incomingFile.chunks[i]);
                    const fullBase64 = ordered.join('');
                    const byteStr = atob(fullBase64);
                    const bytes = new Uint8Array(byteStr.length);
                    for (let i = 0; i < byteStr.length; i++) bytes[i] = byteStr.charCodeAt(i);
                    const iv = bytes.slice(0, 12);
                    const mimeLen = bytes[12];
                    const mimeBytes = bytes.slice(13, 13 + mimeLen);
                    const mime = new TextDecoder().decode(mimeBytes);
                    const data = bytes.slice(13 + mimeLen);

                    window.crypto.subtle.decrypt({name:"AES-GCM", iv}, sharedKey, data)
                        .then(decrypted => {
                            const blob = new Blob([decrypted], { type: mime });
                            const url = URL.createObjectURL(blob);
                            const link = document.createElement('a');
                            link.href = url;
                            link.download = `received_file.${mime.split('/')[1]}`;
                            link.click();
                            alert("File Received & Decrypted Successfully!");
                            setIncomingFile({ id: null, chunks: {}, total: 0 });
                        })
                        .catch(e => { alert("Decryption Failed"); setIncomingFile({ id: null, chunks: {}, total: 0 }); });
                }
            }, [incomingFile, sharedKey]);

            const send = async () => {
                if(!sharedKey || !msg) return;
                const iv = window.crypto.getRandomValues(new Uint8Array(12));
                const enc = await window.crypto.subtle.encrypt({name:"AES-GCM", iv}, sharedKey, new TextEncoder().encode(msg));
                const pkt = JSON.stringify({iv:buf2hex(iv), d:buf2hex(enc)});
                setChat(prev => [...prev, {from:'Me', text:msg}]);
                setMsg("");
                // Just display QR for chat for simplicity or audio
                // In real use, better to append to chat log directly
            };

            return (
                <div className={`min-h-screen flex flex-col ${isDarth ? 'bg-red-950 border-4 border-red-600' : ''}`}>
                    <header className={`p-4 flex justify-between items-center shadow-lg ${isDarth ? 'bg-red-900' : 'bg-slate-900'}`}>
                        <div className="flex items-center gap-2 text-white font-bold">
                            <Icon p={isDarth ? icons.skull : icons.shield} /> 
                            <span>CryptoVis {isDarth && "DARTH"}</span>
                        </div>
                        <div className="flex gap-3">
                            <button onClick={genKeys}><Icon p={icons.refresh}/></button>
                            <label className="flex items-center gap-2 text-xs text-white/70">
                                <input type="checkbox" checked={isDarth} onChange={e => setIsDarth(e.target.checked)} /> Darth
                            </label>
                        </div>
                    </header>

                    <div className="flex bg-slate-800 text-xs font-bold text-slate-400">
                        {['CONNECT','VERIFY','CHAT'].map(t => (
                            <button key={t} onClick={()=>setActiveTab(t)} className={`flex-1 py-3 ${activeTab===t ? 'text-cyan-400 bg-slate-700' : ''}`}>{t}</button>
                        ))}
                    </div>

                    <main className="flex-1 p-4 space-y-6 max-w-md mx-auto w-full">
                        {activeTab === 'CONNECT' && (
                            <div className="glass p-6 rounded-xl text-center space-y-4 animate-in fade-in">
                                <h2 className="text-white font-bold">1. Share Identity (RSA Public Key)</h2>
                                <div className="flex justify-center"><QRDisplay data={myPublicKeyStr} label="My RSA Key" /></div>
                                
                                <div className="grid grid-cols-2 gap-2">
                                    <button onClick={() => setScanner('QR')} className="btn-primary bg-cyan-600 hover:bg-cyan-500 text-white font-bold py-2 rounded flex items-center justify-center gap-2">
                                        <Icon p={icons.cam} /> Scan Partner
                                    </button>
                                    <button onClick={initiateHandshake} disabled={!partnerKeyStr} className={`btn-primary font-bold py-2 rounded flex items-center justify-center gap-2 ${partnerKeyStr ? 'bg-emerald-600 text-white' : 'bg-slate-700 text-slate-500'}`}>
                                        <Icon p={icons.key} /> 2. Send Session Key
                                    </button>
                                </div>
                                <button onClick={() => setAudioMode('RECEIVER')} className="w-full bg-cyan-900/50 border border-cyan-500 hover:bg-cyan-900 text-cyan-200 py-3 rounded font-bold flex items-center justify-center gap-2">
                                    <Icon p={icons.mic}/> Listen for Session Key
                                </button>
                            </div>
                        )}

                        {activeTab === 'VERIFY' && (
                            <div className="glass p-6 rounded-xl text-center space-y-4 animate-in fade-in">
                                <h2 className="text-yellow-400 font-bold uppercase">Hybrid Session Secure</h2>
                                {sharedKey ? (
                                    <>
                                        <div className="bg-slate-900 p-4 rounded-xl text-4xl">{fingerprint}</div>
                                        <p className="text-slate-400 text-sm">Fingerprint of AES Session Key (Decrypted via RSA)</p>
                                    </>
                                ) : <div className="text-red-400">Not Connected</div>}
                            </div>
                        )}

                        {activeTab === 'CHAT' && (
                            <div className="space-y-4 animate-in fade-in">
                                <div className="glass h-48 overflow-y-auto p-4 space-y-2 rounded-xl">
                                    {chat.map((c,i) => <div key={i} className={`text-sm p-2 rounded ${c.from==='Me'?'bg-cyan-900/50 ml-auto text-right':'bg-slate-700'}`}>{c.text}</div>)}
                                </div>
                                <div className="flex gap-2">
                                    <input value={msg} onChange={e=>setMsg(e.target.value)} className="flex-1 bg-slate-800 rounded px-3 text-white" placeholder="Message..." />
                                    <button onClick={send} className="bg-cyan-600 px-3 py-2 rounded text-white"><Icon p={icons.send}/></button>
                                </div>
                            </div>
                        )}
                    </main>

                    {scanner === 'QR' && <QRScanner onScan={handleData} onClose={()=>setScanner(null)} />}
                    
                    {audioMode && (
                        <SonicTransceiver 
                            mode={audioMode} 
                            dataToSend={handshakePayload} // Now sends Encrypted AES Key, NOT Public Key
                            onData={d => { handleData(d); }} 
                            onAck={() => { alert("Session Key Transferred!"); setAudioMode(null); }}
                            onClose={() => setAudioMode(null)} 
                        />
                    )}

                    {fileTransfer && <AnimatedQR chunks={fileTransfer.chunks} label="Broadcasting File" onClose={()=>setFileTransfer(null)} />}
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
