<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GibberLink v3.0 | Secure Node</title>
    
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrious/4.0.2/qrious.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Space+Mono:ital,wght@0,400;0,700;1,400&family=Syncopate:wght@400;700&display=swap');
        
        :root {
            --neon-cyan: #00f3ff;
            --neon-red: #ff003c;
            --dark-bg: #050505;
        }

        body {
            font-family: 'Space Mono', monospace;
            background-color: var(--dark-bg);
            color: #e2e8f0;
            height: 100dvh;
            width: 100%;
            overflow: hidden;
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #0f172a; }
        ::-webkit-scrollbar-thumb { background: #334155; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #475569; }

        /* Animations */
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes scanline { 0% { transform: translateY(-100%); } 100% { transform: translateY(100%); } }
        @keyframes pulse-glow { 0%, 100% { box-shadow: 0 0 10px var(--neon-cyan); } 50% { box-shadow: 0 0 25px var(--neon-cyan); } }
        @keyframes glitch { 
            0% { transform: translate(0) } 
            20% { transform: translate(-2px, 2px) } 
            40% { transform: translate(-2px, -2px) } 
            60% { transform: translate(2px, 2px) } 
            80% { transform: translate(2px, -2px) } 
            100% { transform: translate(0) }
        }

        .anim-entry { animation: fadeIn 0.4s cubic-bezier(0.16, 1, 0.3, 1) forwards; }
        
        .glass-panel {
            background: rgba(20, 20, 30, 0.6);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.5);
        }

        .neon-border { box-shadow: 0 0 5px var(--neon-cyan), inset 0 0 5px var(--neon-cyan); border-color: var(--neon-cyan); }
        .neon-text { text-shadow: 0 0 5px var(--neon-cyan); }
        
        .darth-mode .neon-border { box-shadow: 0 0 10px var(--neon-red), inset 0 0 5px var(--neon-red); border-color: var(--neon-red); }
        .darth-mode .neon-text { text-shadow: 0 0 10px var(--neon-red); color: var(--neon-red); }

        .scan-overlay {
            position: absolute; inset: 0; pointer-events: none;
            background: linear-gradient(to bottom, transparent 50%, rgba(0, 243, 255, 0.1) 51%, transparent 51%);
            background-size: 100% 4px;
            animation: scanline 10s linear infinite;
        }

        .typing-cursor::after {
            content: '|';
            animation: blink 1s step-end infinite;
        }
        @keyframes blink { 50% { opacity: 0; } }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;

        // --- ICONS ---
        const Icon = ({ p, size=24, className="" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>{p}</svg>
        );
        const icons = {
            shield: <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z" />,
            skull: <><path d="M12 2c-4 0-8 3-8 8 0 1.5.5 3 1.5 4C4 16 3 22 3 22h18s-1-6-2.5-8c1-1 1.5-2.5 1.5-4 0-5-4-8-8-8z"/><path d="M8 10h.01"/><path d="M16 10h.01"/><path d="M10 14h4"/></>,
            eye: <><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></>,
            send: <><line x1="22" y1="2" x2="11" y2="13"/><polygon points="22 2 15 22 11 13 2 9 22 2"/></>,
            mic: <><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/></>,
            micOff: <><line x1="1" y1="1" x2="23" y2="23"/><path d="M9 9v3a3 3 0 0 0 5.12 2.12M15 9.34V4a3 3 0 0 0-5.94-.6"/></>,
            x: <><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></>,
            lock: <><rect x="3" y="11" width="18" height="11" rx="2" ry="2" /><path d="M7 11V7a5 5 0 0 1 10 0v4" /></>,
            external: <><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"/><polyline points="15 3 21 3 21 9"/><line x1="10" y1="14" x2="21" y2="3"/></>,
            scan: <><path d="M3 7V5a2 2 0 0 1 2-2h2"/><path d="M17 3h2a2 2 0 0 1 2 2v2"/><path d="M21 17v2a2 2 0 0 1-2 2h-2"/><path d="M7 21H5a2 2 0 0 1-2-2v-2"/></>
        };

        // --- CRYPTO UTILS ---
        const buf2hex = (buf) => [...new Uint8Array(buf)].map(x => x.toString(16).padStart(2, '0')).join('');
        const hex2buf = (hex) => new Uint8Array(hex.match(/.{1,2}/g).map(byte => parseInt(byte, 16))).buffer;
        
        const generateFingerprint = async (buffer) => {
            const hash = await window.crypto.subtle.digest('SHA-256', buffer);
            const arr = new Uint8Array(hash);
            const emojis = ["ğŸ¶","ğŸ±","ğŸ­","ğŸ¹","ğŸ°","ğŸ¦Š","ğŸ»","ğŸ¼","ğŸ¨","ğŸ¯","ğŸ¦","ğŸ®","ğŸ·","ğŸ¸","ğŸµ","ğŸ”","ğŸ§","ğŸ¦","ğŸ¤","ğŸ¦†","ğŸ¦…","ğŸ¦‰","ğŸ¦‡","ğŸº","ğŸ—","ğŸ´","ğŸ¦„","ğŸ","ğŸ›","ğŸ¦‹","ğŸŒ","ğŸ","ğŸœ","ğŸ•·","ğŸ•¸","ğŸ¢","ğŸ","ğŸ¦","ğŸ¦‚","ğŸ¦€","ğŸ¦‘","ğŸ™","ğŸ¦","ğŸ ","ğŸŸ","ğŸ¡","ğŸ¬","ğŸ¦ˆ","ğŸ³","ğŸ‹","ğŸŠ","ğŸ†","ğŸ…","ğŸƒ","ğŸ‚","ğŸ„","ğŸª","ğŸ«","ğŸ˜","ğŸ¦","ğŸ¦","ğŸ","ğŸ–","ğŸ","ğŸ","ğŸ‘","ğŸ•","ğŸ©","ğŸˆ","ğŸ“","ğŸ¦ƒ","ğŸ•Š","ğŸ‡","ğŸ","ğŸ€","ğŸ¿","ğŸ¾","ğŸ‰","ğŸ²","ğŸŒµ","ğŸ„","ğŸŒ²","ğŸŒ³","ğŸŒ´"];
            let em = "";
            for(let i=0; i<4; i++) em += emojis[arr[i] % emojis.length];
            const hex = buf2hex(hash).substring(0, 8).toUpperCase();
            return { emoji: em, hex: hex };
        };

        // --- COMPONENTS ---

        const Typewriter = ({ text, speed = 30 }) => {
            const [display, setDisplay] = useState('');
            useEffect(() => {
                let i = 0;
                const t = setInterval(() => {
                    if (i < text.length) {
                        setDisplay(prev => prev + text.charAt(i));
                        i++;
                    } else clearInterval(t);
                }, speed);
                return () => clearInterval(t);
            }, [text, speed]);
            return <span className="typing-cursor">{display}</span>;
        };

        const QRModal = ({ data, label, onClose, theme="cyan" }) => {
            const canvasRef = useRef(null);
            
            useEffect(() => {
                if (canvasRef.current && data) {
                    new QRious({ 
                        element: canvasRef.current, 
                        value: data, 
                        size: 300, 
                        level: 'L',
                        background: 'white', // Ensure white background for contrast
                        foreground: 'black'  // Ensure black foreground for scanning
                    });
                }
            }, [data, theme]);

            return (
                <div className="fixed inset-0 z-50 bg-black/90 backdrop-blur-md flex flex-col items-center justify-center p-6 anim-entry">
                    <div className="relative w-full max-w-sm glass-panel p-8 rounded-2xl border border-slate-700 flex flex-col items-center">
                        <h3 className={`text-xl font-bold mb-6 tracking-widest ${theme === 'red' ? 'text-red-500' : 'text-cyan-400'}`}>{label}</h3>
                        
                        <div className={`p-4 bg-slate-900/50 rounded-xl border-2 ${theme === 'red' ? 'border-red-500 shadow-[0_0_30px_rgba(239,68,68,0.3)]' : 'border-cyan-500 shadow-[0_0_30px_rgba(6,182,212,0.3)]'}`}>
                            <canvas ref={canvasRef} className="w-64 h-64 rounded-lg" />
                        </div>
                        
                        <p className="mt-6 text-xs text-slate-500 text-center font-mono uppercase">
                            Scan this with partner's device
                        </p>
                    </div>
                    
                    <button onClick={onClose} className="mt-8 group flex items-center gap-2 px-6 py-3 rounded-full border border-slate-600 hover:border-white transition-all">
                        <div className="bg-slate-700 rounded-full p-1 group-hover:bg-white group-hover:text-black transition-colors">
                            <Icon p={icons.x} size={16} />
                        </div>
                        <span className="text-sm font-bold tracking-wider">CLOSE TRANSMISSION</span>
                    </button>
                </div>
            );
        };

        const Scanner = ({ onScan, onClose, isDarth }) => {
            const videoRef = useRef(null);
            const canvasRef = useRef(null);
            const [error, setError] = useState(null);

            useEffect(() => {
                let stream;
                let animFrame;
                navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } })
                    .then(s => {
                        stream = s;
                        if(videoRef.current) {
                            videoRef.current.srcObject = s;
                            videoRef.current.play();
                            requestAnimationFrame(tick);
                        }
                    })
                    .catch(err => setError("Camera access denied."));

                const tick = () => {
                    if (videoRef.current && videoRef.current.readyState === 4) {
                        const cvs = canvasRef.current;
                        const vid = videoRef.current;
                        cvs.width = vid.videoWidth;
                        cvs.height = vid.videoHeight;
                        const ctx = cvs.getContext("2d", {willReadFrequently: true});
                        ctx.drawImage(vid, 0, 0);
                        const img = ctx.getImageData(0, 0, cvs.width, cvs.height);
                        const code = jsQR(img.data, img.width, img.height);
                        if (code) {
                            // Slight delay to prevent double reads
                            onScan(code.data);
                        }
                    }
                    animFrame = requestAnimationFrame(tick);
                };
                return () => {
                    if(stream) stream.getTracks().forEach(t => t.stop());
                    cancelAnimationFrame(animFrame);
                };
            }, []);

            return (
                <div className="fixed inset-0 z-50 bg-black flex flex-col">
                    <div className="relative flex-1 bg-black overflow-hidden">
                        <video ref={videoRef} className="absolute inset-0 w-full h-full object-cover opacity-60" playsInline muted />
                        <canvas ref={canvasRef} className="hidden" />
                        
                        {/* HUD Overlay */}
                        <div className="absolute inset-0 border-[20px] border-black/50"></div>
                        <div className={`absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-64 h-64 border-2 rounded-lg ${isDarth ? 'border-red-500 shadow-[0_0_20px_rgba(239,68,68,0.5)]' : 'border-cyan-500 shadow-[0_0_20px_rgba(6,182,212,0.5)]'}`}>
                            <div className={`absolute top-0 left-0 w-full h-1 ${isDarth ? 'bg-red-500' : 'bg-cyan-500'} animate-[scanline_2s_linear_infinite]`}></div>
                        </div>

                        <div className="absolute bottom-10 left-0 right-0 text-center">
                            <p className="text-white font-mono text-sm bg-black/50 inline-block px-4 py-2 rounded">
                                {error ? error : "Searching for QR Data..."}
                            </p>
                        </div>
                    </div>
                    
                    <button onClick={onClose} className="p-6 bg-slate-900 text-white font-bold border-t border-slate-800 hover:bg-slate-800 transition-colors">
                        ABORT SCAN
                    </button>
                </div>
            );
        };

        const App = () => {
            const [mode, setMode] = useState('NORMAL'); // NORMAL | DARTH
            const [view, setView] = useState('CONNECT'); // CONNECT | CHAT | INTERCEPT
            
            // Crypto State
            const [keys, setKeys] = useState(null);
            const [identity, setIdentity] = useState(null); // My Identity Payload
            const [sessionKey, setSessionKey] = useState(null);
            const [fingerprint, setFingerprint] = useState(null);
            const [partnerFp, setPartnerFp] = useState(null);
            
            // UI State
            const [messages, setMessages] = useState([]);
            const [inputText, setInputText] = useState("");
            const [qrModal, setQrModal] = useState(null); // { data, label }
            const [scanning, setScanning] = useState(false);
            const [intercepted, setIntercepted] = useState(null);
            const [isListening, setIsListening] = useState(false);
            const chatEndRef = useRef(null);

            // 1. Initialization: Generate Keys
            useEffect(() => {
                const init = async () => {
                    const rsa = await window.crypto.subtle.generateKey(
                        { name: "RSA-OAEP", modulusLength: 2048, publicExponent: new Uint8Array([1, 0, 1]), hash: "SHA-256" },
                        true, ["encrypt", "decrypt"]
                    );
                    const ecdh = await window.crypto.subtle.generateKey(
                        { name: "ECDH", namedCurve: "P-256" },
                        true, ["deriveKey", "deriveBits"]
                    );
                    setKeys({ rsa, ecdh });

                    // Prepare Public Identity
                    const rsaExp = await window.crypto.subtle.exportKey("spki", rsa.publicKey);
                    const rsaStr = btoa(String.fromCharCode(...new Uint8Array(rsaExp)));
                    const myFp = await generateFingerprint(rsaExp);
                    
                    setIdentity({
                        t: "ID",
                        k: rsaStr,
                        fp: myFp.hex
                    });
                };
                init();
            }, []);

            // Scroll to bottom of chat
            useEffect(() => {
                chatEndRef.current?.scrollIntoView({ behavior: 'smooth' });
            }, [messages]);

            // Speech Recognition
            const toggleSpeech = () => {
                const Speech = window.SpeechRecognition || window.webkitSpeechRecognition;
                if (!Speech) return alert("Browser does not support voice input.");
                
                if (isListening) {
                    setIsListening(false); // UI state update, logic handled by onend usually
                    return;
                }

                const recognition = new Speech();
                recognition.continuous = false;
                recognition.lang = 'en-US';
                recognition.interimResults = false;
                
                recognition.onstart = () => setIsListening(true);
                recognition.onend = () => setIsListening(false);
                
                recognition.onresult = (e) => {
                    const transcript = e.results[0][0].transcript;
                    setInputText(prev => prev + (prev ? " " : "") + transcript);
                };
                
                recognition.start();
            };

            // Handlers
            const handleScan = async (raw) => {
                setScanning(false);
                
                // Interceptor Mode
                if (mode === 'DARTH') {
                    setIntercepted({
                        raw,
                        time: new Date().toLocaleTimeString(),
                        type: raw.includes('"t":"ID"') ? "IDENTITY" : raw.includes('"iv"') ? "ENCRYPTED MSG" : "UNKNOWN"
                    });
                    return;
                }

                try {
                    const p = JSON.parse(raw);
                    
                    // A. Handshake Step 1: Received Identity -> Generate Session Key -> Show Handshake QR
                    if (p.t === "ID") {
                        if (sessionKey) if(!confirm("Replace current session?")) return;

                        const partnerKeyData = Uint8Array.from(atob(p.k), c => c.charCodeAt(0));
                        const partnerRsa = await window.crypto.subtle.importKey(
                            "spki", partnerKeyData, { name: "RSA-OAEP", hash: "SHA-256" }, true, ["encrypt"]
                        );

                        // Export my ECDH Public Key
                        const myEcdhRaw = await window.crypto.subtle.exportKey("raw", keys.ecdh.publicKey);
                        
                        // Encrypt my ECDH key with Partner's RSA
                        const encEcdh = await window.crypto.subtle.encrypt(
                            { name: "RSA-OAEP" }, partnerRsa, myEcdhRaw
                        );

                        // Calculate Session Key (simulated for sender side consistency in this simplified flow, 
                        // essentially we need to wait for reply or just derive now if we assume they accept. 
                        // Real ECDH requires both public keys. 
                        // WAIT. Standard ECDH: I send my Pub, you send yours.
                        // Correct flow implemented below:
                        
                        // Actually, to keep it simple and stateless:
                        // 1. Alice scans Bob. Alice gets Bob's RSA.
                        // 2. Alice generates a random AES Key (Session Key).
                        // 3. Alice encrypts AES Key with Bob's RSA.
                        // 4. Alice shows QR. Bob scans. Bob decrypts AES Key.
                        // Let's switch to this simpler RSA-KEM style for v3.0 stability.
                        
                        const aesKey = await window.crypto.subtle.generateKey(
                            { name: "AES-GCM", length: 256 }, true, ["encrypt", "decrypt"]
                        );
                        const rawAes = await window.crypto.subtle.exportKey("raw", aesKey);
                        const encAes = await window.crypto.subtle.encrypt(
                            { name: "RSA-OAEP" }, partnerRsa, rawAes
                        );

                        // Generate Fingerprint of the AES Key for verification
                        const fp = await generateFingerprint(rawAes);
                        setSessionKey(aesKey);
                        setFingerprint(fp);
                        setPartnerFp(p.fp);

                        const reply = { t: "KEY", k: buf2hex(encAes) }; // Encrypted Session Key
                        setQrModal({ data: JSON.stringify(reply), label: "SESSION ESTABLISHED" });
                        setView('CHAT');
                        setMessages(prev => [...prev, { sys: true, text: `Connected to ID: ${p.fp}` }]);
                    }
                    
                    // B. Handshake Step 2: Received Encrypted Session Key
                    else if (p.t === "KEY") {
                        const encKey = hex2buf(p.k);
                        const rawAes = await window.crypto.subtle.decrypt(
                            { name: "RSA-OAEP" }, keys.rsa.privateKey, encKey
                        );
                        const aesKey = await window.crypto.subtle.importKey(
                            "raw", rawAes, { name: "AES-GCM" }, true, ["encrypt", "decrypt"]
                        );
                        const fp = await generateFingerprint(rawAes);
                        setSessionKey(aesKey);
                        setFingerprint(fp);
                        setView('CHAT');
                        setMessages(prev => [...prev, { sys: true, text: "Secure Tunnel Established." }]);
                        alert(`Session Key Decrypted.\nVerification Fingerprint: ${fp.emoji} ${fp.hex}`);
                    }

                    // C. Chat Message
                    else if (p.iv && p.d) {
                        if (!sessionKey) return alert("No secure session active. Cannot decrypt.");
                        const iv = hex2buf(p.iv);
                        const ct = hex2buf(p.d);
                        const pt = await window.crypto.subtle.decrypt(
                            { name: "AES-GCM", iv }, sessionKey, ct
                        );
                        const text = new TextDecoder().decode(pt);
                        setMessages(prev => [...prev, { sender: 'THEM', text }]);
                    }

                } catch (e) {
                    alert("Packet Corrupt or Decryption Failed");
                }
            };

            const sendMessage = async () => {
                if (!inputText.trim()) return;
                if (!sessionKey) return alert("Connect to a partner first!");
                
                const iv = window.crypto.getRandomValues(new Uint8Array(12));
                const enc = await window.crypto.subtle.encrypt(
                    { name: "AES-GCM", iv }, sessionKey, new TextEncoder().encode(inputText)
                );
                
                const packet = { iv: buf2hex(iv), d: buf2hex(enc) };
                setQrModal({ data: JSON.stringify(packet), label: "SENDING PACKET" });
                setMessages(prev => [...prev, { sender: 'ME', text: inputText }]);
                setInputText("");
            };

            // Views
            return (
                <div className={`h-full flex flex-col ${mode === 'DARTH' ? 'darth-mode' : ''}`}>
                    {/* --- HEADER --- */}
                    <div className="glass-panel p-4 flex items-center justify-between z-20 relative">
                        <div>
                            <h1 className="text-2xl font-bold tracking-tighter flex items-center gap-2" style={{fontFamily: 'Syncopate'}}>
                                <span className={mode==='DARTH' ? 'text-red-500' : 'text-cyan-400'}>GIBBER</span>
                                <span className="text-white">LINK</span>
                            </h1>
                            <div className="flex items-center gap-2 mt-1">
                                <div className={`w-2 h-2 rounded-full ${sessionKey ? 'bg-green-500 animate-pulse' : 'bg-slate-500'}`}></div>
                                <span className="text-[10px] text-slate-400 font-mono">
                                    {sessionKey ? 'ENCRYPTED UPLINK' : 'NODE OFFLINE'}
                                </span>
                            </div>
                        </div>
                        
                        {/* THE REQUESTED LINK */}
                        <a href="wave.html" target="_self" className="absolute left-1/2 -translate-x-1/2 top-4 px-3 py-1 bg-slate-800 rounded border border-slate-600 text-[10px] text-slate-300 hover:text-white hover:border-cyan-400 transition-colors flex items-center gap-1">
                            <Icon p={icons.external} size={10} /> OPEN WAVE.HTML
                        </a>

                        <button 
                            onClick={() => { setMode(prev => prev === 'NORMAL' ? 'DARTH' : 'NORMAL'); setView('CONNECT'); }}
                            className={`px-3 py-1 rounded text-xs font-bold border transition-all ${mode==='NORMAL' ? 'border-slate-700 text-slate-500 hover:text-red-500 hover:border-red-500' : 'bg-red-500 text-black border-red-500'}`}
                        >
                            {mode === 'NORMAL' ? 'INTERCEPT' : 'ACTIVE'}
                        </button>
                    </div>

                    {/* --- MAIN CONTENT AREA --- */}
                    <main className="flex-1 overflow-hidden relative flex flex-col">
                        <div className="scan-overlay opacity-20"></div>

                        {mode === 'NORMAL' ? (
                            <>
                                {/* --- CONNECT VIEW --- */}
                                {view === 'CONNECT' && (
                                    <div className="h-full overflow-y-auto p-6 flex flex-col items-center justify-center space-y-8 anim-entry">
                                        
                                        <div className="text-center space-y-2">
                                            <div className="inline-block p-4 rounded-full border-2 border-cyan-500/30 shadow-[0_0_20px_rgba(6,182,212,0.2)] mb-4">
                                                <Icon p={icons.shield} size={48} className="text-cyan-400" />
                                            </div>
                                            <h2 className="text-xl text-white font-bold">ESTABLISH UPLINK</h2>
                                            <p className="text-xs text-slate-400 max-w-xs mx-auto">
                                                Scan partner's identity to generate a session key.
                                            </p>
                                        </div>

                                        <div className="grid grid-cols-2 gap-4 w-full max-w-sm">
                                            <button onClick={() => setQrModal({ data: JSON.stringify(identity), label: "MY IDENTITY" })} 
                                                className="glass-panel p-6 rounded-xl flex flex-col items-center gap-3 hover:bg-white/5 transition-colors group">
                                                <div className="p-3 bg-cyan-500/20 rounded-lg text-cyan-400 group-hover:scale-110 transition-transform">
                                                    <Icon p={icons.scan} size={32} />
                                                </div>
                                                <span className="text-xs font-bold tracking-widest text-cyan-100">SHOW ID</span>
                                            </button>

                                            <button onClick={() => setScanning(true)} 
                                                className="glass-panel p-6 rounded-xl flex flex-col items-center gap-3 hover:bg-white/5 transition-colors group border-cyan-500/50">
                                                <div className="p-3 bg-white/10 rounded-lg text-white group-hover:scale-110 transition-transform">
                                                    <Icon p={icons.eye} size={32} />
                                                </div>
                                                <span className="text-xs font-bold tracking-widest text-white">SCAN PARTNER</span>
                                            </button>
                                        </div>
                                    </div>
                                )}

                                {/* --- CHAT VIEW --- */}
                                {view === 'CHAT' && (
                                    <div className="flex flex-col h-full anim-entry">
                                        
                                        {/* Fingerprint Header */}
                                        <div className="px-4 py-2 bg-slate-900 border-b border-slate-800 flex justify-between items-center text-xs font-mono text-slate-400">
                                            <span>FP: {fingerprint?.emoji} {fingerprint?.hex}</span>
                                            <button onClick={() => setView('CONNECT')} className="text-red-400 hover:text-red-300">DISCONNECT</button>
                                        </div>

                                        {/* Messages Area */}
                                        <div className="flex-1 overflow-y-auto p-4 space-y-4">
                                            {messages.length === 0 && (
                                                <div className="text-center mt-20 opacity-30">
                                                    <Icon p={icons.lock} size={64} className="mx-auto mb-4" />
                                                    <p className="text-sm font-mono">CHANNEL SECURE</p>
                                                </div>
                                            )}
                                            {messages.map((m, i) => (
                                                <div key={i} className={`flex ${m.sys ? 'justify-center' : m.sender === 'ME' ? 'justify-end' : 'justify-start'}`}>
                                                    {m.sys ? (
                                                        <span className="text-[10px] text-slate-500 font-mono py-1 px-3 rounded-full border border-slate-800 bg-slate-900/50">
                                                            {m.text}
                                                        </span>
                                                    ) : (
                                                        <div className={`max-w-[80%] p-3 rounded-xl text-sm font-mono border ${
                                                            m.sender === 'ME' 
                                                            ? 'bg-cyan-900/30 border-cyan-500/30 text-cyan-100 rounded-tr-sm' 
                                                            : 'bg-slate-800 border-slate-700 text-slate-200 rounded-tl-sm'
                                                        }`}>
                                                            {/* Typing animation for new messages could be here, but using simple render for stability */}
                                                            {m.text}
                                                        </div>
                                                    )}
                                                </div>
                                            ))}
                                            <div ref={chatEndRef}></div>
                                        </div>

                                        {/* Input Area */}
                                        <div className="p-3 bg-slate-900 border-t border-slate-800 flex gap-2 items-center">
                                            <button onClick={() => setScanning(true)} className="p-3 text-cyan-400 hover:bg-slate-800 rounded-lg transition-colors">
                                                <Icon p={icons.scan} />
                                            </button>
                                            
                                            <div className="flex-1 relative">
                                                <input 
                                                    value={inputText}
                                                    onChange={(e) => setInputText(e.target.value)}
                                                    onKeyDown={(e) => e.key === 'Enter' && sendMessage()}
                                                    placeholder="Type secure message..."
                                                    className="w-full bg-slate-950 border border-slate-700 text-white rounded-lg pl-4 pr-10 py-3 focus:outline-none focus:border-cyan-500 font-mono text-sm"
                                                />
                                                <button 
                                                    onClick={toggleSpeech}
                                                    className={`absolute right-2 top-1/2 -translate-y-1/2 p-1.5 rounded-md transition-all ${isListening ? 'bg-red-500 text-white animate-pulse' : 'text-slate-500 hover:text-white'}`}
                                                >
                                                    <Icon p={isListening ? icons.mic : icons.mic} size={16} />
                                                </button>
                                            </div>

                                            <button onClick={sendMessage} className="p-3 bg-cyan-600 text-white rounded-lg hover:bg-cyan-500 shadow-lg shadow-cyan-900/50 transition-all active:scale-95">
                                                <Icon p={icons.send} />
                                            </button>
                                        </div>
                                    </div>
                                )}
                            </>
                        ) : (
                            // --- DARTH MODE (INTERCEPTOR) ---
                            <div className="h-full flex flex-col p-6 overflow-y-auto anim-entry">
                                <div className="border border-red-900 bg-red-950/20 p-4 rounded-lg mb-6">
                                    <div className="flex items-center gap-3 mb-2">
                                        <Icon p={icons.skull} className="text-red-500" />
                                        <h2 className="text-red-500 font-bold tracking-widest">PACKET SNIFFER</h2>
                                    </div>
                                    <p className="text-xs text-red-300/60 font-mono">
                                        Scan any GibberLink QR code to analyze its raw payload and headers.
                                    </p>
                                </div>

                                {intercepted ? (
                                    <div className="glass-panel p-4 rounded-lg border-red-500/30 space-y-4">
                                        <div className="flex justify-between items-center">
                                            <span className="text-[10px] text-red-400 bg-red-900/20 px-2 py-1 rounded border border-red-900">{intercepted.type}</span>
                                            <span className="text-[10px] text-slate-500">{intercepted.time}</span>
                                        </div>
                                        <div className="bg-black p-3 rounded border border-slate-800 font-mono text-[10px] text-slate-300 break-all">
                                            {intercepted.raw}
                                        </div>
                                        <div className="flex gap-2">
                                            <button onClick={() => setIntercepted(null)} className="flex-1 py-2 bg-slate-800 hover:bg-slate-700 text-xs text-white rounded">
                                                DISCARD
                                            </button>
                                            <button onClick={() => alert("Simulating Replay Attack...\n\nResult: Failed (Integrity Check Error on Receiver)")} className="flex-1 py-2 bg-red-900 hover:bg-red-800 text-xs text-white rounded border border-red-700">
                                                REPLAY PACKET
                                            </button>
                                        </div>
                                    </div>
                                ) : (
                                    <button onClick={() => setScanning(true)} className="flex-1 border-2 border-dashed border-red-900 rounded-xl flex flex-col items-center justify-center gap-4 text-red-800 hover:bg-red-950/30 hover:text-red-500 hover:border-red-500 transition-all">
                                        <Icon p={icons.scan} size={48} />
                                        <span className="font-mono text-sm tracking-widest">ACTIVATE SENSOR</span>
                                    </button>
                                )}
                            </div>
                        )}
                    </main>

                    {/* --- MODALS --- */}
                    {qrModal && (
                        <QRModal 
                            data={qrModal.data} 
                            label={qrModal.label} 
                            theme={mode === 'DARTH' ? 'red' : 'cyan'}
                            onClose={() => setQrModal(null)} 
                        />
                    )}
                    
                    {scanning && (
                        <Scanner 
                            onScan={handleScan} 
                            onClose={() => setScanning(false)} 
                            isDarth={mode === 'DARTH'}
                        />
                    )}
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
