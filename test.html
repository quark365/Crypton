<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>ShadowLink | Secure P2P</title>
    
    <!-- React & DOM -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>    
    
    <!-- Tailwind -->
    <!-- <script src="https://cdn.tailwindcss.com"></script> -->
    <script src="https://unpkg.com/@tailwindcss/browser@4"></script>
    
    <!-- QR Tools -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrious/4.0.2/qrious.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>
    
    <!-- Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;500;700&family=JetBrains+Mono:wght@400;700&display=swap');
        
        :root {
            --neon-cyan: #00f3ff;
            --neon-purple: #bc13fe;
            --bg-dark: #050510;
        }

        body {
            background-color: var(--bg-dark);
            color: #e2e8f0;
            font-family: 'Space Grotesk', sans-serif;
            overflow: hidden;
            touch-action: manipulation;
        }

        .app-height {
            height: 100vh;
            height: 100dvh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* CRT/Scanline Effects */
        .scanline {
            width: 100%; height: 2px;
            background: var(--neon-cyan);
            position: absolute;
            animation: scan 2s linear infinite;
            box-shadow: 0 0 15px var(--neon-cyan);
            z-index: 50;
            pointer-events: none;
        }
        @keyframes scan { 0% { top: 0%; opacity: 0; } 50% { opacity: 1; } 100% { top: 100%; opacity: 0; } }

        .glass-panel {
            background: rgba(15, 23, 42, 0.7);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.08);
        }

        /* Utilities */
        .font-mono { font-family: 'JetBrains Mono', monospace; }
        .hide-scrollbar::-webkit-scrollbar { display: none; }
        .hide-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        .fade-in { animation: fadeIn 0.3s ease-in; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        /* Messages */
        .msg-bubble { max-width: 85%; padding: 12px 16px; border-radius: 20px; position: relative; word-break: break-word; line-height: 1.5; }
        .msg-me { background: linear-gradient(135deg, #06b6d4, #2563eb); color: white; border-bottom-right-radius: 4px; margin-left: auto; box-shadow: 0 4px 15px rgba(6, 182, 212, 0.2); }
        .msg-other { background: #1e293b; color: #e2e8f0; border-bottom-left-radius: 4px; margin-right: auto; border: 1px solid rgba(255,255,255,0.05); }
        .msg-sys { text-align: center; width: 100%; margin: 16px 0; opacity: 0.8; }
        .sys-pill { background: rgba(15, 23, 42, 0.9); color: #22d3ee; font-size: 11px; padding: 6px 16px; border-radius: 999px; font-family: 'JetBrains Mono', monospace; border: 1px solid rgba(34, 211, 238, 0.2); backdrop-filter: blur(4px); }

        .pb-safe { padding-bottom: env(safe-area-inset-bottom); }

        /* Recording Pulse */
        .pulse-ring {
            box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7);
            animation: pulse-red 1.5s infinite cubic-bezier(0.66, 0, 0, 1);
        }
        @keyframes pulse-red {
            to { box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo, useCallback } = React;

        // --- CONFIG ---
        const CHUNK_SIZE = 250;
        const ICE_SERVERS = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };
        const FILE_CHUNK_SIZE = 16384; 
        const EMOJIS = ["üëç", "‚ù§Ô∏è", "üòÇ", "üòÆ", "üò¢", "üò°", "üéâ", "üî•", "üëª", "ü§ñ", "üëÄ", "üöÄ", "üíÄ", "üí©", "üëã", "‚úÖ"];
        
        // --- UTILS ---
        const buf2hex = (buf) => [...new Uint8Array(buf)].map(x => x.toString(16).padStart(2, '0')).join('');
        const hex2buf = (hex) => new Uint8Array(hex.match(/.{1,2}/g).map(byte => parseInt(byte, 16))).buffer;
        
        const arrayBufferToBase64 = (buffer) => {
            let binary = '';
            const bytes = new Uint8Array(buffer);
            for (let i = 0; i < bytes.byteLength; i++) binary += String.fromCharCode(bytes[i]);
            return window.btoa(binary);
        };
        const base64ToArrayBuffer = (base64) => {
            const binary_string = window.atob(base64);
            const len = binary_string.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) bytes[i] = binary_string.charCodeAt(i);
            return bytes.buffer;
        };

        const formatTime = (seconds) => {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        };

        // --- COMPONENTS ---

        // FIXED: Crash-proof Icon component. 
        const Icon = ({ name, size = 24, className, onClick }) => {
            const ref = useRef(null);

            useEffect(() => {
                if(!window.lucide || !ref.current) return;
                
                const el = document.createElement('i');
                el.setAttribute('data-lucide', name);
                
                ref.current.innerHTML = '';
                ref.current.appendChild(el);
                
                window.lucide.createIcons({
                    root: ref.current,
                    attrs: {
                        width: size,
                        height: size,
                    }
                });
            }, [name, size]);

            return (
                <span 
                    ref={ref} 
                    onClick={onClick} 
                    className={`inline-flex items-center justify-center ${className || ''}`}
                    style={{ cursor: onClick ? 'pointer' : 'default' }}
                >
                </span>
            );
        };

        const QRAnimator = ({ data, label }) => {
            const [index, setIndex] = useState(0);
            const canvasRef = useRef(null);
            
            const chunks = useMemo(() => {
                if(!data) return [];
                const str = typeof data === 'string' ? data : JSON.stringify(data);
                const b64 = btoa(str); 
                const total = Math.ceil(b64.length / CHUNK_SIZE);
                const arr = [];
                for(let i=0; i<total; i++) {
                    arr.push(`SL:${i}:${total}:${b64.slice(i*CHUNK_SIZE, (i+1)*CHUNK_SIZE)}`);
                }
                return arr;
            }, [data]);

            useEffect(() => {
                if(chunks.length <= 1) return;
                const interval = setInterval(() => {
                    setIndex(prev => (prev + 1) % chunks.length);
                }, 250);
                return () => clearInterval(interval);
            }, [chunks]);

            useEffect(() => {
                if(canvasRef.current && chunks.length > 0) {
                    new QRious({
                        element: canvasRef.current,
                        value: chunks[index],
                        size: 250,
                        level: 'L',
                        foreground: '#000',
                        background: '#fff'
                    });
                }
            }, [index, chunks]);

            return (
                <div className="flex flex-col items-center bg-white p-4 rounded-xl shadow-[0_0_30px_rgba(0,243,255,0.2)]">
                    <canvas ref={canvasRef} className="rounded-lg mb-2"></canvas>
                    <div className="w-full bg-slate-200 h-1 rounded overflow-hidden">
                        <div className="h-full bg-cyan-500 transition-all duration-100" 
                             style={{width: `${((index+1)/chunks.length)*100}%`}}></div>
                    </div>
                    <p className="text-black font-mono text-xs mt-2 font-bold">{label} ({index+1}/{chunks.length})</p>
                </div>
            );
        };

        const QRScanner = ({ onScan }) => {
            const videoRef = useRef(null);
            const canvasRef = useRef(null);
            const [status, setStatus] = useState("Initializing Camera...");

            const scanLoop = useCallback(() => {
                const video = videoRef.current;
                const canvas = canvasRef.current;
                if(!video || !canvas) return;

                if (video.readyState === video.HAVE_ENOUGH_DATA) {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    const ctx = canvas.getContext("2d", { willReadFrequently: true });
                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const code = jsQR(imageData.data, imageData.width, imageData.height);
                    
                    if (code && code.data.startsWith('SL:')) {
                        setStatus("Packet Detected");
                        onScan(code.data);
                    } else {
                        setStatus("Scanning...");
                    }
                }
                requestAnimationFrame(scanLoop);
            }, [onScan]);

            useEffect(() => {
                let stream = null;
                navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } })
                    .then(s => {
                        stream = s;
                        if(videoRef.current) {
                            videoRef.current.srcObject = stream;
                            videoRef.current.play().catch(e => console.error(e));
                            requestAnimationFrame(scanLoop);
                        }
                    })
                    .catch(err => setStatus("Camera Error: " + err.message));
                
                return () => {
                    if(stream) stream.getTracks().forEach(t => t.stop());
                };
            }, [scanLoop]);

            return (
                <div className="relative w-full max-w-sm aspect-square bg-black rounded-2xl overflow-hidden border-2 border-cyan-500/50 shadow-2xl">
                    <video ref={videoRef} className="absolute inset-0 w-full h-full object-cover opacity-80" muted playsInline></video>
                    <canvas ref={canvasRef} className="hidden"></canvas>
                    <div className="scanline"></div>
                    <div className="absolute bottom-4 left-0 right-0 text-center">
                        <span className={`text-xs px-3 py-1 rounded-full font-mono backdrop-blur-md transition-colors ${status === "Packet Detected" ? "bg-green-500/80 text-white" : "bg-black/60 text-cyan-400"}`}>{status}</span>
                    </div>
                </div>
            );
        };

        const IdentityModal = ({ fingerprint, onClose }) => {
            if (!fingerprint) return null;
            return (
                <div className="fixed inset-0 z-[100] bg-black/80 backdrop-blur-sm flex items-center justify-center p-4 fade-in">
                    <div className="bg-slate-900 border border-slate-700 p-8 rounded-3xl max-w-sm w-full text-center relative shadow-2xl">
                        <button onClick={onClose} className="absolute top-4 right-4 p-2 text-slate-500 hover:text-white">
                            <Icon name="x" size={20} />
                        </button>
                        <div className="w-16 h-16 bg-cyan-500/10 rounded-full flex items-center justify-center mx-auto mb-4 border border-cyan-500/30">
                            <Icon name="shield-check" size={32} className="text-cyan-400" />
                        </div>
                        <h3 className="text-xl font-bold text-white mb-2">Safety Number</h3>
                        <p className="text-slate-400 text-sm mb-6">Compare with peer.</p>
                        <div className="bg-black/50 p-6 rounded-2xl border border-slate-800 mb-6">
                            <div className="text-5xl mb-4 tracking-widest">{fingerprint.emoji}</div>
                            <div className="font-mono text-cyan-400 text-lg tracking-[0.2em] break-all">{fingerprint.hex}</div>
                        </div>
                        <button onClick={onClose} className="w-full py-3 bg-cyan-600 hover:bg-cyan-500 rounded-xl font-bold text-white transition-colors">Verified</button>
                    </div>
                </div>
            );
        };

        // --- CALL UI COMPONENT (UPDATED) ---
        const CallOverlay = ({ status, localStream, remoteStream, onAnswer, onHangup, isVideo, onToggleMute, onToggleVideo }) => {
            const localVideoRef = useRef(null);
            const remoteVideoRef = useRef(null);
            
            // UI States
            const [isMuted, setIsMuted] = useState(false);
            const [isCameraOff, setIsCameraOff] = useState(false);

            // Sync Local Video
            useEffect(() => {
                if (localVideoRef.current && localStream) {
                    localVideoRef.current.srcObject = localStream;
                }
            }, [localStream, isCameraOff]); 

            // Sync Remote Video
            useEffect(() => {
                // Ensure we attempt to play even if it failed before or was audio-only
                if (remoteVideoRef.current && remoteStream) {
                    remoteVideoRef.current.srcObject = remoteStream;
                    remoteVideoRef.current.play().catch(e => console.log("Auto-play err", e));
                }
            }, [remoteStream]);

            // Handlers
            const handleMuteClick = () => {
                const success = onToggleMute();
                if(success) setIsMuted(prev => !prev);
            };

            const handleVideoClick = () => {
                const success = onToggleVideo();
                if(success) setIsCameraOff(prev => !prev);
            };

            if (status === 'IDLE') return null;

            // FIX: Robust check for video tracks
            const remoteHasVideo = remoteStream && remoteStream.getVideoTracks().length > 0;

            return (
                <div className="fixed inset-0 z-[70] bg-black/95 flex flex-col items-center justify-center app-height animate-fade-in backdrop-blur-md">
                    
                    {/* Main Video/Audio Container */}
                    <div className="relative w-full h-full max-w-7xl max-h-[100dvh] mx-auto bg-slate-900 overflow-hidden md:rounded-2xl shadow-2xl flex items-center justify-center">
                        
                        {/* Remote Stream Layer - FIXED: Removed 'hidden' class to ensure Audio plays even if Video is missing */}
                        <video 
                            ref={remoteVideoRef} 
                            autoPlay 
                            playsInline 
                            className="w-full h-full object-cover absolute inset-0 z-0" 
                        />

                        {/* Audio-only Avatar Visualization (Overlay on top if video is missing) */}
                        {!remoteHasVideo && (
                            <div className="absolute inset-0 w-full h-full flex flex-col items-center justify-center bg-slate-900 bg-[radial-gradient(ellipse_at_center,_var(--tw-gradient-stops))] from-slate-800 to-slate-950 z-10">
                                <div className="relative">
                                    <div className={`absolute inset-0 bg-cyan-500 rounded-full blur-2xl opacity-20 ${status === 'ACTIVE' ? 'animate-pulse' : ''}`}></div>
                                    <div className="w-40 h-40 rounded-full bg-gradient-to-br from-cyan-500/20 to-purple-500/20 border border-white/10 flex items-center justify-center relative z-10 shadow-[0_0_50px_rgba(6,182,212,0.15)]">
                                        <Icon name="user" size={80} className="text-cyan-100/50" />
                                    </div>
                                </div>
                                <p className="text-slate-400 font-mono tracking-widest text-sm uppercase mt-8 animate-pulse">
                                    {status === 'ACTIVE' ? 'Voice Connected' : status === 'OUTGOING' ? 'Calling...' : 'Connecting...'}
                                </p>
                            </div>
                        )}

                        {/* Local Video (PiP) */}
                        {localStream && isVideo && !isCameraOff && (
                            <div className="absolute top-6 right-6 w-32 h-48 sm:w-48 sm:h-64 bg-black rounded-2xl overflow-hidden shadow-2xl border border-slate-700/50 z-20 transition-all hover:scale-105">
                                <video ref={localVideoRef} autoPlay playsInline muted className="w-full h-full object-cover transform scale-x-[-1]" />
                            </div>
                        )}

                        {/* Controls Overlay */}
                        <div className="absolute bottom-0 w-full p-8 pb-16 bg-gradient-to-t from-black/90 via-black/50 to-transparent z-30">
                            <div className="max-w-md mx-auto">
                                <div className="text-center mb-8">
                                    <h3 className="text-3xl font-bold text-white mb-2 text-shadow-lg tracking-tight">
                                        {status === 'INCOMING' ? 'Incoming Call...' : status === 'OUTGOING' ? 'Calling...' : 'Connected'}
                                    </h3>
                                    <div className="text-emerald-400 font-mono text-xs font-bold tracking-widest uppercase flex items-center justify-center gap-2">
                                        {status === 'ACTIVE' && <div className="w-2 h-2 bg-emerald-500 rounded-full animate-pulse"></div>}
                                        {status === 'ACTIVE' ? 'Secure Feed' : 'Encrypting...'}
                                    </div>
                                </div>

                                <div className="flex items-center justify-center gap-8">
                                    {status === 'INCOMING' ? (
                                        <>
                                            <button onClick={onHangup} className="flex flex-col items-center gap-2 group">
                                                <div className="p-5 bg-red-500/20 text-red-500 border border-red-500/50 rounded-full shadow-lg group-hover:bg-red-500 group-hover:text-white transition-all backdrop-blur-md">
                                                    <Icon name="phone-off" size={32} />
                                                </div>
                                                <span className="text-xs font-bold text-red-400 uppercase tracking-wider">Decline</span>
                                            </button>

                                            <button onClick={onAnswer} className="flex flex-col items-center gap-2 group">
                                                <div className="p-5 bg-green-500 rounded-full text-white shadow-[0_0_30px_rgba(34,197,94,0.4)] group-hover:bg-green-400 group-hover:scale-110 transition-all animate-bounce">
                                                    <Icon name="phone" size={32} />
                                                </div>
                                                <span className="text-xs font-bold text-green-400 uppercase tracking-wider">Accept</span>
                                            </button>
                                        </>
                                    ) : (
                                        <>
                                            {/* MUTE BUTTON */}
                                            <button 
                                                onClick={handleMuteClick} 
                                                className={`p-5 rounded-full transition-all backdrop-blur-md border shadow-lg ${
                                                    isMuted 
                                                        ? 'bg-red-600 border-red-500 text-white hover:bg-red-500' 
                                                        : 'bg-white/10 border-white/20 text-white hover:bg-white/20'
                                                }`}
                                            >
                                                <Icon key={isMuted ? "mic-off" : "mic"} name={isMuted ? "mic-off" : "mic"} size={28} />
                                            </button>
                                            
                                            {/* HANGUP BUTTON */}
                                            <button onClick={onHangup} className="p-6 bg-red-600 rounded-full text-white shadow-xl hover:bg-red-500 hover:scale-110 transition-all border-4 border-black/30">
                                                <Icon name="phone-off" size={36} />
                                            </button>

                                            {/* VIDEO TOGGLE - ONLY IF VIDEO CALL */}
                                            {isVideo && (
                                                <button 
                                                    onClick={handleVideoClick} 
                                                    className={`p-5 rounded-full transition-all backdrop-blur-md border shadow-lg ${
                                                        isCameraOff 
                                                            ? 'bg-red-600 border-red-500 text-white hover:bg-red-500' 
                                                            : 'bg-white/10 border-white/20 text-white hover:bg-white/20'
                                                    }`}
                                                >
                                                    <Icon key={isCameraOff ? "video-off" : "video"} name={isCameraOff ? "video-off" : "video"} size={28} />
                                                </button>
                                            )}
                                        </>
                                    )}
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        // --- CAMERA COMPONENT ---
        const CameraModal = ({ onClose, onCapture }) => {
            const videoRef = useRef(null);
            const canvasRef = useRef(null);
            const mediaRecorderRef = useRef(null);
            const [stream, setStream] = useState(null);
            const [mode, setMode] = useState('PHOTO'); // PHOTO or VIDEO
            const [isRecording, setIsRecording] = useState(false);
            const [preview, setPreview] = useState(null); // { type: 'image'|'video', url, blob }
            const [timer, setTimer] = useState(0);

            useEffect(() => {
                let s = null;
                navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: "environment" }, 
                    audio: true 
                }).then(mediaStream => {
                    s = mediaStream;
                    setStream(mediaStream);
                    if(videoRef.current) {
                        videoRef.current.srcObject = mediaStream;
                        videoRef.current.play();
                    }
                }).catch(err => console.error("Cam Access Denied", err));
                return () => {
                    if(s) s.getTracks().forEach(t => t.stop());
                }
            }, []);

            useEffect(() => {
                let interval;
                if(isRecording) {
                    interval = setInterval(() => setTimer(t => t+1), 1000);
                } else {
                    setTimer(0);
                }
                return () => clearInterval(interval);
            }, [isRecording]);

            const takePhoto = () => {
                if(!videoRef.current || !canvasRef.current) return;
                const w = videoRef.current.videoWidth;
                const h = videoRef.current.videoHeight;
                canvasRef.current.width = w;
                canvasRef.current.height = h;
                const ctx = canvasRef.current.getContext('2d');
                ctx.drawImage(videoRef.current, 0, 0, w, h);
                canvasRef.current.toBlob(blob => {
                    setPreview({ type: 'image', url: URL.createObjectURL(blob), blob });
                }, 'image/jpeg', 0.85);
            };

            const toggleVideo = () => {
                if(isRecording) {
                    mediaRecorderRef.current.stop();
                    setIsRecording(false);
                } else {
                    const chunks = [];
                    const mr = new MediaRecorder(stream, { mimeType: 'video/webm' });
                    mr.ondataavailable = e => { if(e.data.size > 0) chunks.push(e.data); };
                    mr.onstop = () => {
                        const blob = new Blob(chunks, { type: 'video/webm' });
                        setPreview({ type: 'video', url: URL.createObjectURL(blob), blob });
                    };
                    mr.start();
                    mediaRecorderRef.current = mr;
                    setIsRecording(true);
                }
            };

            const handleSend = () => {
                if(preview) {
                    const name = preview.type === 'image' ? `photo_${Date.now()}.jpg` : `video_${Date.now()}.webm`;
                    const type = preview.type === 'image' ? 'image/jpeg' : 'video/webm';
                    onCapture(preview.blob, name, type);
                    onClose();
                }
            };

            const retake = () => {
                setPreview(null);
            };

            return (
                <div className="fixed inset-0 z-[60] bg-black/95 flex flex-col app-height items-center justify-center p-4">
                    <div className="w-full max-w-5xl h-full max-h-[90vh] flex flex-col relative bg-black rounded-2xl overflow-hidden shadow-2xl border border-slate-800">
                        {/* Header */}
                        <div className="p-4 flex justify-between items-center bg-black/50 absolute top-0 w-full z-10 pb-safe backdrop-blur-sm">
                            <button onClick={onClose} className="text-white bg-white/10 p-2 rounded-full hover:bg-white/20 transition-colors"><Icon name="x" /></button>
                            {isRecording && <div className="text-red-500 font-mono font-bold animate-pulse bg-black/50 px-3 py-1 rounded-full">REC {formatTime(timer)}</div>}
                            <div className="w-8"></div>
                        </div>

                        {/* Main View */}
                        <div className="flex-1 relative bg-black flex items-center justify-center overflow-hidden">
                            {!preview ? (
                                <>
                                    <video ref={videoRef} className="absolute inset-0 w-full h-full object-cover" muted playsInline></video>
                                    <canvas ref={canvasRef} className="hidden"></canvas>
                                    {/* Crosshair */}
                                    <div className="absolute inset-0 pointer-events-none flex items-center justify-center opacity-30">
                                        <div className="w-64 h-64 border border-white/50 rounded-lg"></div>
                                        <div className="w-2 h-2 bg-white/80 rounded-full"></div>
                                    </div>
                                </>
                            ) : (
                                <div className="relative w-full h-full bg-black flex items-center justify-center">
                                    {preview.type === 'image' ? 
                                        <img src={preview.url} className="max-w-full max-h-full object-contain" alt="preview" /> : 
                                        <video src={preview.url} controls className="max-w-full max-h-full object-contain" />
                                    }
                                </div>
                            )}
                        </div>

                        {/* Controls */}
                        <div className="bg-black/80 flex items-center justify-around pb-safe py-6 backdrop-blur-md">
                            {!preview ? (
                                <>
                                    <div className="flex gap-4">
                                        <button onClick={() => setMode('PHOTO')} className={`text-sm font-bold ${mode === 'PHOTO' ? 'text-yellow-400' : 'text-gray-500'} hover:text-white transition-colors`}>PHOTO</button>
                                        <button onClick={() => setMode('VIDEO')} className={`text-sm font-bold ${mode === 'VIDEO' ? 'text-yellow-400' : 'text-gray-500'} hover:text-white transition-colors`}>VIDEO</button>
                                    </div>
                                    <button 
                                        onClick={mode === 'PHOTO' ? takePhoto : toggleVideo}
                                        className={`w-16 h-16 rounded-full border-4 border-white flex items-center justify-center transition-all cursor-pointer hover:scale-105 ${isRecording ? 'bg-red-500 scale-110' : 'bg-transparent active:scale-95'}`}
                                    >
                                        <div className={`rounded-full transition-all ${mode === 'PHOTO' ? 'bg-white w-12 h-12' : 'bg-red-500 w-10 h-10'}`}></div>
                                    </button>
                                    <div className="w-12"></div> {/* Spacer */}
                                </>
                            ) : (
                                <div className="flex w-full justify-around items-center">
                                    <button onClick={retake} className="text-white font-bold hover:text-cyan-400 transition-colors">Retake</button>
                                    <button onClick={handleSend} className="bg-cyan-500 text-black px-8 py-3 rounded-full font-bold text-lg hover:bg-cyan-400 hover:scale-105 transition-all shadow-lg shadow-cyan-500/20">Send</button>
                                </div>
                            )}
                        </div>
                    </div>
                </div>
            );
        };

        // --- MAIN APP ---
        const App = () => {
            const [view, setView] = useState('HOME');
            const [role, setRole] = useState(null);
            const [logs, setLogs] = useState([]);
            const [msgText, setMsgText] = useState("");
            const [messages, setMessages] = useState([]);
            const [showVerify, setShowVerify] = useState(false);
            const [fileProgress, setFileProgress] = useState(0); 
            const [showCamera, setShowCamera] = useState(false);
            const [showEmoji, setShowEmoji] = useState(false);
            
            // Audio Recording State
            const [isRecordingAudio, setIsRecordingAudio] = useState(false);
            const [audioTimer, setAudioTimer] = useState(0);
            const audioRecorderRef = useRef(null);
            const audioChunksRef = useRef([]);

            // WebRTC Refs
            const pc = useRef(null);
            const dc = useRef(null);
            const candidates = useRef([]);
            
            // Crypto Refs
            const keys = useRef({ rsa: null, ecdh: null });
            const sessionKey = useRef(null);
            const fingerprint = useRef(null);
            const incomingFiles = useRef({});
            const fileInputRef = useRef(null);
            const chatEndRef = useRef(null);

            // Signaling State
            const [localSignal, setLocalSignal] = useState(null);
            const scannedChunks = useRef(new Map());
            const [scanProgress, setScanProgress] = useState(0);

            // Call State
            const [callStatus, setCallStatus] = useState('IDLE'); // IDLE, OUTGOING, INCOMING, ACTIVE
            const [localStream, setLocalStream] = useState(null);
            const localStreamRef = useRef(null); // Ref to hold active stream for immediate access in toggles
            const [remoteStream, setRemoteStream] = useState(null);
            const [isVideoCall, setIsVideoCall] = useState(false);
            const pendingOffer = useRef(null);

            // Initial Key Gen
            useEffect(() => {
                const initKeys = async () => {
                    // Generate RSA Keys for Identity
                    keys.current.rsa = await window.crypto.subtle.generateKey(
                        { name: "RSA-OAEP", modulusLength: 2048, publicExponent: new Uint8Array([1, 0, 1]), hash: "SHA-256" },
                        true, ["encrypt", "decrypt"]
                    );
                    // Generate ECDH Keys for Session Secrecy
                    keys.current.ecdh = await window.crypto.subtle.generateKey(
                        { name: "ECDH", namedCurve: "P-256" },
                        true, ["deriveKey", "deriveBits"]
                    );
                    addLog("Crypto System Initialized (RSA + ECDH).");
                };
                initKeys();
            }, []);

            // Auto-scroll
            useEffect(() => {
                if (chatEndRef.current) chatEndRef.current.scrollIntoView({ behavior: "smooth" });
            }, [messages]);

            // Audio Timer
            useEffect(() => {
                let interval;
                if(isRecordingAudio) {
                    interval = setInterval(() => setAudioTimer(t => t+1), 1000);
                } else {
                    setAudioTimer(0);
                }
                return () => clearInterval(interval);
            }, [isRecordingAudio]);

            const addLog = (txt) => setLogs(p => [...p.slice(-4), txt]);

            // WebRTC Setup
            const createPeer = useCallback(() => {
                const peer = new RTCPeerConnection(ICE_SERVERS);
                
                peer.onicecandidate = (e) => { 
                    if (e.candidate) {
                        if (dc.current && dc.current.readyState === 'open') {
                             dc.current.send(JSON.stringify({ t: 'SIG_ICE', c: e.candidate }));
                        } else {
                            candidates.current.push(e.candidate); 
                        }
                    } 
                };
                
                peer.onconnectionstatechange = () => addLog(`Connection: ${peer.connectionState}`);
                
                peer.ontrack = (e) => {
                    const stream = e.streams[0] || new MediaStream([e.track]);
                    // FORCE UPDATE: Create a new MediaStream reference to ensure React detects the change
                    // FIXED: Accumulate tracks more reliably
                    setRemoteStream(new MediaStream(stream.getTracks()));
                };

                pc.current = peer;
                return peer;
            }, []);

            const processSignal = useCallback(async (data) => {
                if (!pc.current) return;
                
                if(role === 'HOST' && data.type === 'answer') {
                    await pc.current.setRemoteDescription(new RTCSessionDescription(data.sdp));
                    data.candidates.forEach(c => pc.current.addIceCandidate(new RTCIceCandidate(c)));
                    addLog("Remote Desc Set.");
                } else if (role === 'JOINER' && data.type === 'offer') {
                    await pc.current.setRemoteDescription(new RTCSessionDescription(data.sdp));
                    data.candidates.forEach(c => pc.current.addIceCandidate(new RTCIceCandidate(c)));
                    
                    const answer = await pc.current.createAnswer();
                    await pc.current.setLocalDescription(answer);
                    await new Promise(r => setTimeout(r, 500)); // Gather candidates
                    
                    setLocalSignal({
                        type: 'answer',
                        sdp: pc.current.localDescription,
                        candidates: candidates.current
                    });
                    setView('JOIN_WAIT');
                }
            }, [role]);

            const handleScannedChunk = useCallback((raw) => {
                const parts = raw.split(':');
                if(parts.length < 4) return;
                const idx = parseInt(parts[1]);
                const total = parseInt(parts[2]);
                const data = parts.slice(3).join(':');

                if(!scannedChunks.current.has(idx)) {
                    scannedChunks.current.set(idx, data);
                    setScanProgress(Math.round((scannedChunks.current.size / total) * 100));
                    
                    if(scannedChunks.current.size === total) {
                        const fullB64 = Array.from({length: total}, (_, i) => scannedChunks.current.get(i)).join('');
                        try {
                            const jsonStr = atob(fullB64);
                            const signalData = JSON.parse(jsonStr);
                            addLog("Signal Captured.");
                            scannedChunks.current.clear();
                            processSignal(signalData);
                        } catch(e) {
                            console.error("Signal parse error", e);
                            addLog("Error Parsing Signal");
                        }
                    }
                }
            }, [processSignal]);

            const startHost = async () => {
                setRole('HOST');
                const peer = createPeer();
                dc.current = peer.createDataChannel("shadowlink");
                setupDataChannel(dc.current);
                const offer = await peer.createOffer();
                await peer.setLocalDescription(offer);
                await new Promise(r => setTimeout(r, 500));
                setLocalSignal({ type: 'offer', sdp: peer.localDescription, candidates: candidates.current });
                setView('HOST_WAIT');
            };

            const startJoin = () => {
                setRole('JOINER');
                const peer = createPeer();
                peer.ondatachannel = (e) => {
                    dc.current = e.channel;
                    setupDataChannel(dc.current);
                };
                setView('SCAN_HOST');
            };

            const setupDataChannel = (channel) => {
                channel.onopen = () => {
                    addLog("Tunnel Open.");
                    initiateSecureHandshake();
                };
                channel.onmessage = async (e) => handlePacket(e.data);
            };

            // Hybrid Cryptography Handshake (RSA Identity + ECDH Session)
            const initiateSecureHandshake = async () => {
                const rsaPub = await window.crypto.subtle.exportKey("spki", keys.current.rsa.publicKey);
                const ecdhPub = await window.crypto.subtle.exportKey("raw", keys.current.ecdh.publicKey);
                dc.current.send(JSON.stringify({ t: 'HELLO', rsa: buf2hex(rsaPub), ecdh: buf2hex(ecdhPub) }));
            };

            const deriveSession = async (p) => {
                // Import Peer's RSA Key (Identity)
                const peerRsa = await window.crypto.subtle.importKey("spki", hex2buf(p.rsa), { name: "RSA-OAEP", hash: "SHA-256" }, true, ["encrypt"]);
                // Import Peer's ECDH Key (Diffie-Hellman)
                const peerEcdh = await window.crypto.subtle.importKey("raw", hex2buf(p.ecdh), { name: "ECDH", namedCurve: "P-256" }, true, []);
                
                // Derive Shared Secret
                const sharedBits = await window.crypto.subtle.deriveBits({ name: "ECDH", public: peerEcdh }, keys.current.ecdh.privateKey, 256);
                
                // Create Session Key (AES-GCM)
                const hkdfKey = await window.crypto.subtle.importKey("raw", sharedBits, { name: "HKDF" }, false, ["deriveKey"]);
                sessionKey.current = await window.crypto.subtle.deriveKey(
                    { name: "HKDF", hash: "SHA-256", salt: new Uint8Array(), info: new TextEncoder().encode("ShadowLink") },
                    hkdfKey, { name: "AES-GCM", length: 256 }, false, ["encrypt", "decrypt"]
                );

                // Generate Fingerprint from RSA+ECDH data (Safety Number)
                const fpHash = await window.crypto.subtle.digest("SHA-256", sharedBits);
                const fpArr = new Uint8Array(fpHash);
                const emojis = ["üíÄ","üëΩ","ü§ñ","üëª","ü§°","üëπ","üë∫","üëæ","üéÉ","üêâ","ü¶Ñ","ü¶â","üï∏","‚ö°","üî•","‚ùÑÔ∏è"];
                let fpEmoji = "";
                for(let i=0; i<4; i++) fpEmoji += emojis[fpArr[i] % emojis.length];
                const fpHex = buf2hex(fpHash).substring(0, 8).toUpperCase();
                fingerprint.current = { emoji: fpEmoji, hex: fpHex };
                
                addLog(`Secured: ${fpEmoji}`);
                setView('CHAT');
                setMessages(prev => [...prev, { id: Date.now(), type: 'SYS', text: `SECURE CHANNEL ESTABLISHED` }]);
            };

            const handlePacket = async (raw) => {
                try {
                    const p = JSON.parse(raw);
                    
                    if (p.t === 'HELLO') {
                        await deriveSession(p);
                    } 
                    else if (p.t === 'ENC') {
                        const pt = await decryptData(p.iv, p.d);
                        const text = new TextDecoder().decode(pt);
                        setMessages(prev => [...prev, { id: Date.now(), type: 'RX', text: text }]);
                    }
                    else if (p.t === 'SIG_OFFER') {
                        pendingOffer.current = p.sdp;
                        setIsVideoCall(p.video);
                        setCallStatus('INCOMING');
                    }
                    else if (p.t === 'SIG_ANSWER') {
                        if (pc.current.signalingState !== 'stable') {
                            await pc.current.setRemoteDescription(new RTCSessionDescription(p.sdp));
                            setCallStatus('ACTIVE');
                        }
                    }
                    else if (p.t === 'SIG_ICE') {
                        await pc.current.addIceCandidate(new RTCIceCandidate(p.c));
                    }
                    else if (p.t === 'CALL_END') {
                        endCallCleanup();
                    }
                    else if (p.t === 'FILE_HEADER') {
                        const pt = await decryptData(p.iv, p.meta);
                        const meta = JSON.parse(new TextDecoder().decode(pt));
                        incomingFiles.current[p.id] = { meta, chunks: [], receivedSize: 0, startTime: Date.now() };
                        setMessages(prev => [...prev, { id: Date.now(), type: 'SYS', text: `Receiving ${meta.name}...` }]);
                    }
                    else if (p.t === 'FILE_CHUNK') {
                        const fileCtx = incomingFiles.current[p.id];
                        if (fileCtx) {
                            const chunkData = base64ToArrayBuffer(p.d);
                            fileCtx.chunks.push({ idx: p.idx, data: chunkData });
                            fileCtx.receivedSize += chunkData.byteLength;
                            
                            if (fileCtx.receivedSize >= fileCtx.meta.encSize) {
                                fileCtx.chunks.sort((a,b) => a.idx - b.idx);
                                const totalLen = fileCtx.chunks.reduce((acc, c) => acc + c.data.byteLength, 0);
                                const cipherBuffer = new Uint8Array(totalLen);
                                let offset = 0;
                                fileCtx.chunks.forEach(c => {
                                    cipherBuffer.set(new Uint8Array(c.data), offset);
                                    offset += c.data.byteLength;
                                });

                                try {
                                    const fileData = await window.crypto.subtle.decrypt(
                                        { name: "AES-GCM", iv: hex2buf(fileCtx.meta.iv) },
                                        sessionKey.current,
                                        cipherBuffer
                                    );
                                    
                                    const blob = new Blob([fileData], { type: fileCtx.meta.type });
                                    const url = URL.createObjectURL(blob);
                                    
                                    setMessages(prev => [...prev, { 
                                        id: Date.now(), 
                                        type: 'FILE', 
                                        text: fileCtx.meta.name,
                                        fileUrl: url,
                                        fileSize: fileCtx.meta.size,
                                        mimeType: fileCtx.meta.type
                                    }]);
                                    delete incomingFiles.current[p.id];
                                } catch(e) {
                                    console.error("Decrypt Fail", e);
                                    setMessages(prev => [...prev, { id: Date.now(), type: 'SYS', text: `Decryption Failed` }]);
                                }
                            }
                        }
                    }
                } catch(e) { console.error("Packet Error", e); }
            };

            const decryptData = async (ivHex, dataHex) => {
                return await window.crypto.subtle.decrypt(
                    { name: "AES-GCM", iv: hex2buf(ivHex) },
                    sessionKey.current,
                    hex2buf(dataHex)
                );
            };

            const sendMessage = async () => {
                if(!msgText.trim() || !sessionKey.current) return;
                const txt = msgText;
                setMsgText("");
                setMessages(prev => [...prev, { id: Date.now(), type: 'TX', text: txt }]);
                const iv = window.crypto.getRandomValues(new Uint8Array(12));
                const enc = await window.crypto.subtle.encrypt(
                    { name: "AES-GCM", iv: iv },
                    sessionKey.current,
                    new TextEncoder().encode(txt)
                );
                dc.current.send(JSON.stringify({ t: 'ENC', iv: buf2hex(iv), d: buf2hex(enc) }));
            };

            const processAndSendFile = async (blob, fileName, fileType) => {
                 if (!sessionKey.current) return;
                
                // 1. Read
                const buffer = await blob.arrayBuffer();
                
                // 2. Encrypt File
                const fileIv = window.crypto.getRandomValues(new Uint8Array(12));
                const encryptedFile = await window.crypto.subtle.encrypt(
                    { name: "AES-GCM", iv: fileIv },
                    sessionKey.current,
                    buffer
                );
                
                // 3. Encrypt Metadata
                const fileId = crypto.randomUUID();
                const metaRaw = JSON.stringify({ name: fileName, size: blob.size, type: fileType, iv: buf2hex(fileIv), encSize: encryptedFile.byteLength });
                const metaIv = window.crypto.getRandomValues(new Uint8Array(12));
                const encMeta = await window.crypto.subtle.encrypt(
                    { name: "AES-GCM", iv: metaIv },
                    sessionKey.current,
                    new TextEncoder().encode(metaRaw)
                );

                // 4. Send Header
                dc.current.send(JSON.stringify({
                    t: 'FILE_HEADER',
                    id: fileId,
                    iv: buf2hex(metaIv),
                    meta: buf2hex(encMeta)
                }));
                
                setMessages(prev => [...prev, { id: Date.now(), type: 'SYS', text: `Sending ${fileName}...` }]);

                // 5. Send Chunks
                const totalChunks = Math.ceil(encryptedFile.byteLength / FILE_CHUNK_SIZE);
                let offset = 0;
                
                for (let i = 0; i < totalChunks; i++) {
                    const chunk = encryptedFile.slice(offset, offset + FILE_CHUNK_SIZE);
                    const b64Chunk = arrayBufferToBase64(chunk);
                    if (i % 10 === 0) await new Promise(r => setTimeout(r, 10)); // Flow control
                    dc.current.send(JSON.stringify({ t: 'FILE_CHUNK', id: fileId, idx: i, d: b64Chunk }));
                    offset += FILE_CHUNK_SIZE;
                    setFileProgress(Math.round(((i + 1) / totalChunks) * 100));
                }

                setFileProgress(0);
                
                // Create local preview blob for sender
                const localUrl = URL.createObjectURL(blob);
                setMessages(prev => [...prev, { 
                    id: Date.now(), 
                    type: 'TX_FILE', 
                    text: fileName, 
                    fileUrl: localUrl,
                    mimeType: fileType
                }]);
            };

            const handleFileSelect = (e) => {
                const file = e.target.files[0];
                if (file) processAndSendFile(file, file.name, file.type);
            };

            // --- CALLING LOGIC ---
            const startCall = async (video = false) => {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: video });
                    setLocalStream(stream);
                    localStreamRef.current = stream; // Important for toggles
                    setIsVideoCall(video);
                    
                    stream.getTracks().forEach(track => pc.current.addTrack(track, stream));
                    
                    const offer = await pc.current.createOffer();
                    await pc.current.setLocalDescription(offer);
                    
                    dc.current.send(JSON.stringify({ t: 'SIG_OFFER', sdp: offer, video }));
                    setCallStatus('OUTGOING');
                } catch(e) {
                    console.error("Call Error", e);
                    alert("Could not access camera/microphone");
                }
            };

            const answerCall = async () => {
                try {
                    let stream;
                    try {
                        stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: isVideoCall });
                    } catch(e) {
                        // Fallback if video requested but not available
                        if (isVideoCall) stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                        else throw e;
                    }
                    
                    setLocalStream(stream);
                    localStreamRef.current = stream; // Important for toggles
                    
                    stream.getTracks().forEach(track => pc.current.addTrack(track, stream));
                    
                    await pc.current.setRemoteDescription(new RTCSessionDescription(pendingOffer.current));
                    const answer = await pc.current.createAnswer();
                    await pc.current.setLocalDescription(answer);
                    
                    dc.current.send(JSON.stringify({ t: 'SIG_ANSWER', sdp: answer }));
                    setCallStatus('ACTIVE');
                } catch(e) {
                    console.error("Answer Error", e);
                }
            };

            const endCall = () => {
                dc.current.send(JSON.stringify({ t: 'CALL_END' }));
                endCallCleanup();
            };

            const endCallCleanup = () => {
                if(localStreamRef.current) {
                    localStreamRef.current.getTracks().forEach(t => t.stop());
                    localStreamRef.current = null;
                    setLocalStream(null);
                }
                if (pc.current) {
                    pc.current.getSenders().forEach(sender => pc.current.removeTrack(sender));
                }
                setRemoteStream(null);
                setCallStatus('IDLE');
            };

            // Toggle Functions return true if successful, allowing UI to update
            const toggleMute = () => {
                if(localStreamRef.current) {
                    const audioTrack = localStreamRef.current.getAudioTracks()[0];
                    if(audioTrack) {
                        audioTrack.enabled = !audioTrack.enabled;
                        return true;
                    }
                }
                return false;
            };

            const toggleVideo = () => {
                if(localStreamRef.current) {
                    const videoTrack = localStreamRef.current.getVideoTracks()[0];
                    if(videoTrack) {
                        videoTrack.enabled = !videoTrack.enabled;
                        return true;
                    }
                }
                return false;
            };

            // --- MEDIA HANDLING ---

            const startAudioRecord = async () => {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    const recorder = new MediaRecorder(stream);
                    audioChunksRef.current = [];
                    
                    recorder.ondataavailable = e => audioChunksRef.current.push(e.data);
                    recorder.onstop = () => {
                        const blob = new Blob(audioChunksRef.current, { type: 'audio/webm' });
                        processAndSendFile(blob, `voice_${Date.now()}.webm`, 'audio/webm');
                        stream.getTracks().forEach(t => t.stop());
                    };
                    
                    recorder.start();
                    audioRecorderRef.current = recorder;
                    setIsRecordingAudio(true);
                } catch(e) { console.error("Mic Error", e); }
            };

            const stopAudioRecord = () => {
                if(audioRecorderRef.current && isRecordingAudio) {
                    audioRecorderRef.current.stop();
                    setIsRecordingAudio(false);
                }
            };

            // Render Message Content
            const renderMediaContent = (m) => {
                const type = m.mimeType || '';
                const mediaStyle = "rounded-lg max-h-64 w-auto object-contain mt-2 border border-slate-700 bg-black/50"; 
                
                if (type.startsWith('image/')) {
                    return (
                        <a href={m.fileUrl} target="_blank" rel="noopener noreferrer" className="block cursor-pointer">
                            <img src={m.fileUrl} className={mediaStyle} alt="content" />
                        </a>
                    );
                } 
                else if (type.startsWith('video/')) {
                    return <video src={m.fileUrl} controls className={mediaStyle} />;
                } 
                else if (type.startsWith('audio/')) {
                    return <div className="mt-2 w-full min-w-[200px]">
                        <audio src={m.fileUrl} controls className="w-full h-8" />
                    </div>;
                }
                return (
                    <a href={m.fileUrl} download={m.text} className="mt-2 flex items-center justify-center gap-2 w-full py-2 bg-slate-700 hover:bg-slate-600 text-white rounded-lg text-xs font-bold transition-colors">
                        <Icon name="download" size={14} /> Download File
                    </a>
                );
            };

            // Render Views
            const renderHome = () => (
                <div className="flex flex-col items-center justify-center app-height p-6 space-y-8 animate-fade-in">
                    <div className="text-center space-y-2">
                        <div className="relative inline-block">
                            <Icon name="ghost" size={64} className="text-cyan-400 mx-auto" />
                            <div className="absolute top-0 right-0 w-3 h-3 bg-purple-500 rounded-full animate-ping"></div>
                        </div>
                        <h1 className="text-4xl font-bold tracking-tighter text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-purple-500">
                            ShadowLink
                        </h1>
                        <p className="text-slate-400 text-sm font-mono">Zero-Knowledge Kinetic Mesh</p>
                    </div>
                    
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4 w-full max-w-2xl">
                        <button onClick={startHost} className="group relative overflow-hidden p-6 rounded-2xl bg-slate-800 border border-slate-700 hover:border-cyan-500 transition-all text-left hover:shadow-[0_0_20px_rgba(6,182,212,0.3)]">
                            <div className="absolute top-0 left-0 w-1 h-full bg-cyan-500 group-hover:w-full transition-all duration-300 opacity-20"></div>
                            <h3 className="text-xl font-bold text-white flex items-center gap-2">
                                <Icon name="radio-tower" size={20} /> Host Room
                            </h3>
                            <p className="text-xs text-slate-400 mt-1">Create a secure signal.</p>
                        </button>
                        <button onClick={startJoin} className="group relative overflow-hidden p-6 rounded-2xl bg-slate-800 border border-slate-700 hover:border-purple-500 transition-all text-left hover:shadow-[0_0_20px_rgba(168,85,247,0.3)]">
                            <div className="absolute top-0 left-0 w-1 h-full bg-purple-500 group-hover:w-full transition-all duration-300 opacity-20"></div>
                            <h3 className="text-xl font-bold text-white flex items-center gap-2">
                                <Icon name="scan-line" size={20} /> Join Room
                            </h3>
                            <p className="text-xs text-slate-400 mt-1">Scan a signal to connect.</p>
                        </button>
                    </div>
                </div>
            );

            const renderSignaling = () => {
                const isScanner = view === 'SCAN_HOST' || view === 'SCAN_JOIN';
                const isQR = view === 'HOST_WAIT' || view === 'JOIN_WAIT';
                const title = view === 'HOST_WAIT' ? "Host Signal" : view === 'SCAN_HOST' ? "Scan Host" : view === 'SCAN_JOIN' ? "Scan Reply" : "Your Reply";

                return (
                    <div className="flex flex-col app-height p-4 items-center justify-center space-y-6 fade-in">
                        <div className="w-full max-w-md glass-panel rounded-3xl p-6 relative">
                            <button onClick={() => window.location.reload()} className="absolute top-4 left-4 p-2 bg-slate-800 rounded-full hover:bg-red-500/20 text-slate-400 hover:text-red-400 transition-all">
                                <Icon name="x" size={16} />
                            </button>
                            <div className="text-center mb-6">
                                <h2 className="text-2xl font-bold text-white mb-1">{title}</h2>
                                <p className="text-xs text-cyan-400 font-mono">
                                    {isScanner ? "Point camera at peer's screen" : "Show this to peer"}
                                </p>
                            </div>
                            <div className="flex justify-center min-h-[250px] items-center">
                                {isQR && localSignal && (
                                    <div className="space-y-4 w-full">
                                        <QRAnimator data={localSignal} label="Signal Packet" />
                                        {view === 'HOST_WAIT' && (
                                            <button onClick={() => setView('SCAN_JOIN')} className="w-full py-4 bg-gradient-to-r from-purple-600 to-indigo-600 rounded-xl font-bold shadow-lg shadow-purple-900/40 flex items-center justify-center gap-2 hover:brightness-110 transition-all">
                                                <Icon name="scan-eye" /> I've been Scanned
                                            </button>
                                        )}
                                    </div>
                                )}
                                {isScanner && (
                                    <div className="w-full space-y-4">
                                        <QRScanner onScan={handleScannedChunk} />
                                        {scanProgress > 0 && scanProgress < 100 && (
                                            <div className="w-full bg-slate-800 h-2 rounded-full overflow-hidden">
                                                <div className="h-full bg-green-500 transition-all" style={{width: `${scanProgress}%`}}></div>
                                            </div>
                                        )}
                                    </div>
                                )}
                            </div>
                        </div>
                        <div className="font-mono text-[10px] text-slate-500 bg-black/50 px-4 py-2 rounded-lg">
                            {logs[logs.length-1] || "Initializing..."}
                        </div>
                    </div>
                );
            };

            const renderChat = () => (
                <div className="app-height bg-[#0b141a] flex flex-col overflow-hidden relative">
                    {/* Header */}
                    <header className="px-6 py-3 bg-[#1f2c34]/90 backdrop-blur-md flex items-center justify-between shadow-lg z-10 shrink-0 border-b border-slate-800">
                        <div className="flex items-center gap-4 cursor-pointer group" onClick={() => setShowVerify(true)}>
                            <div className="w-10 h-10 rounded-full bg-gradient-to-br from-cyan-500 to-blue-600 flex items-center justify-center text-white font-bold text-xl shadow-[0_0_15px_rgba(6,182,212,0.5)] group-hover:scale-110 transition-transform">
                                {fingerprint.current?.emoji.substring(0,2)}
                            </div>
                            <div>
                                <h2 className="font-bold text-slate-100 text-sm group-hover:text-cyan-400 transition-colors">Secure Peer</h2>
                                <p className="text-[10px] text-emerald-400 font-mono tracking-wider flex items-center gap-1">
                                    <Icon name="lock" size={10} /> AES-256 + RSA
                                </p>
                            </div>
                        </div>
                        <div className="flex gap-3">
                            <button 
                                onClick={() => startCall(false)} 
                                disabled={callStatus !== 'IDLE'}
                                className={`p-2.5 rounded-full transition-all ${callStatus !== 'IDLE' ? 'opacity-30 cursor-not-allowed bg-slate-800 text-slate-500' : 'text-slate-400 hover:text-white bg-slate-800 hover:bg-green-600'}`}
                            >
                                <Icon name="phone" size={18} />
                            </button>
                            <button 
                                onClick={() => startCall(true)} 
                                disabled={callStatus !== 'IDLE'}
                                className={`p-2.5 rounded-full transition-all ${callStatus !== 'IDLE' ? 'opacity-30 cursor-not-allowed bg-slate-800 text-slate-500' : 'text-slate-400 hover:text-white bg-slate-800 hover:bg-cyan-600'}`}
                            >
                                <Icon name="video" size={18} />
                            </button>
                            <button onClick={() => window.location.reload()} className="p-2.5 text-slate-400 hover:text-white bg-slate-800 hover:bg-red-500 rounded-full transition-all">
                                <Icon name="log-out" size={18} />
                            </button>
                        </div>
                    </header>

                    {/* Messages Area */}
                    <div className="flex-1 overflow-y-auto p-4 space-y-4 bg-[url('https://www.transparenttextures.com/patterns/carbon-fibre.png')] scroll-smooth">
                        {messages.map((m) => (
                            m.type === 'SYS' ? (
                                <div key={m.id} className="msg-sys"><span className="sys-pill">{m.text}</span></div>
                            ) : (
                                <div key={m.id} className={`flex ${['TX', 'TX_FILE'].includes(m.type) ? 'justify-end' : 'justify-start'} animate-fade-in`}>
                                    <div className={`msg-bubble ${['TX', 'TX_FILE'].includes(m.type) ? 'msg-me' : 'msg-other'} shadow-sm text-sm ${['FILE', 'TX_FILE'].includes(m.type) ? 'min-w-[240px]' : 'min-w-[60px]'}`}>
                                        {['FILE', 'TX_FILE'].includes(m.type) ? (
                                            <>
                                                <div className="flex items-center gap-2 mb-2 pb-2 border-b border-white/10">
                                                    <Icon name={m.mimeType?.startsWith('image') ? 'image' : m.mimeType?.startsWith('video') ? 'video' : m.mimeType?.startsWith('audio') ? 'mic' : 'file'} size={14} className="opacity-70" />
                                                    <span className="font-bold text-xs opacity-90 truncate max-w-[150px]">{m.text}</span>
                                                </div>
                                                {renderMediaContent(m)}
                                            </>
                                        ) : (
                                            m.text
                                        )}
                                        <div className="text-[9px] mt-1.5 opacity-50 text-right font-mono flex justify-end gap-1 items-center">
                                            {new Date(m.id).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'})}
                                            {['TX', 'TX_FILE'].includes(m.type) && <Icon name="check" size={10} />}
                                        </div>
                                    </div>
                                </div>
                            )
                        ))}
                        <div ref={chatEndRef}></div>
                    </div>

                    {/* Emoji Picker Popover */}
                    {showEmoji && (
                        <div className="absolute bottom-20 left-4 bg-slate-800 border border-slate-700 p-2 rounded-xl shadow-2xl z-20 grid grid-cols-4 gap-2 animate-fade-in">
                            {EMOJIS.map(e => (
                                <button key={e} onClick={() => { setMsgText(p => p + e); setShowEmoji(false); }} className="text-2xl p-2 hover:bg-slate-700 rounded-lg transition-colors">{e}</button>
                            ))}
                        </div>
                    )}

                    {/* Progress Bar */}
                    {fileProgress > 0 && (
                        <div className="h-1 bg-slate-800 w-full shrink-0">
                            <div className="h-full bg-purple-500 transition-all duration-100" style={{width: `${fileProgress}%`}}></div>
                        </div>
                    )}

                    {/* Input Area */}
                    <div className="p-3 bg-[#1f2c34] flex items-end gap-2 shrink-0 pb-safe border-t border-slate-800 relative z-10">
                        {!isRecordingAudio ? (
                            <>
                                <button onClick={() => setShowEmoji(!showEmoji)} className={`p-3 rounded-full transition-colors ${showEmoji ? 'text-yellow-400 bg-white/10' : 'text-slate-400 hover:text-yellow-400 hover:bg-white/5'}`}>
                                    <Icon name="smile" size={22} />
                                </button>
                                <button onClick={() => fileInputRef.current?.click()} className="p-3 rounded-full text-slate-400 hover:text-cyan-400 hover:bg-white/5 transition-colors">
                                    <Icon name="paperclip" size={22} />
                                    <input type="file" ref={fileInputRef} className="hidden" onChange={handleFileSelect} />
                                </button>
                                <div className="flex-1 bg-[#2a3942] rounded-2xl flex items-center px-4 py-3 hover:bg-[#32414b] transition-colors focus-within:ring-1 focus-within:ring-cyan-500/50 mb-0.5">
                                    <input 
                                        value={msgText}
                                        onChange={e => setMsgText(e.target.value)}
                                        onKeyDown={e => e.key === 'Enter' && sendMessage()}
                                        type="text" placeholder="Message..." className="bg-transparent border-none outline-none text-slate-200 w-full placeholder-slate-500 text-sm"
                                        autoComplete="off"
                                    />
                                    {msgText.length > 0 && (
                                        <button onClick={() => setShowCamera(true)} className="ml-2 text-slate-400 hover:text-white">
                                            <Icon name="camera" size={20} />
                                        </button>
                                    )}
                                </div>
                                {msgText ? (
                                    <button onClick={sendMessage} className="p-3 rounded-full bg-cyan-600 text-white shadow-lg shadow-cyan-500/30 hover:bg-cyan-500 hover:scale-105 transition-all">
                                        <Icon name="send-horizontal" size={22} />
                                    </button>
                                ) : (
                                    <div className="flex gap-1">
                                        <button onClick={() => setShowCamera(true)} className="p-3 rounded-full text-slate-400 hover:text-white hover:bg-white/5 transition-colors">
                                            <Icon name="camera" size={22} />
                                        </button>
                                        <button onClick={startAudioRecord} className="p-3 rounded-full bg-slate-700 text-slate-300 hover:bg-red-500/20 hover:text-red-400 transition-all">
                                            <Icon name="mic" size={22} />
                                        </button>
                                    </div>
                                )}
                            </>
                        ) : (
                            <div className="flex-1 flex items-center gap-4 bg-[#2a3942] rounded-2xl p-2.5 px-4 animate-pulse border border-red-500/30">
                                <div className="w-3 h-3 bg-red-500 rounded-full animate-ping"></div>
                                <span className="text-red-400 font-mono font-bold flex-1">Recording {formatTime(audioTimer)}</span>
                                <button onClick={() => setIsRecordingAudio(false)} className="text-slate-400 text-xs uppercase font-bold px-3 py-1 hover:text-white hover:bg-white/10 rounded">Cancel</button>
                                <button onClick={stopAudioRecord} className="p-2 bg-red-500 rounded-full text-white shadow-lg pulse-ring hover:scale-110 transition-transform">
                                    <Icon name="send-horizontal" size={20} />
                                </button>
                            </div>
                        )}
                    </div>
                    
                    {/* Modals & Overlays */}
                    {showVerify && fingerprint.current && (
                        <IdentityModal fingerprint={fingerprint.current} onClose={() => setShowVerify(false)} />
                    )}

                    {showCamera && (
                        <CameraModal onClose={() => setShowCamera(false)} onCapture={processAndSendFile} />
                    )}

                    {callStatus !== 'IDLE' && (
                        <CallOverlay 
                            status={callStatus} 
                            localStream={localStream} 
                            remoteStream={remoteStream} 
                            isVideo={isVideoCall}
                            onAnswer={answerCall}
                            onHangup={endCall}
                            onToggleMute={toggleMute}
                            onToggleVideo={toggleVideo}
                        />
                    )}
                </div>
            );

            if(view === 'HOME') return renderHome();
            if(view === 'CHAT') return renderChat();
            return renderSignaling();
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
