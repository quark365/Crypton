<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Crypton - IndexedDB Replay + Handshake Expiry</title>

  <!-- DEV UMD / Babel (ok for demo) -->
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://unpkg.com/@tailwindcss/browser@4"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/qrious/4.0.2/qrious.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>

  <style>
    @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Inter:wght@400;600;800&display=swap');
    body { font-family: 'Inter', sans-serif; background-color:#0f172a; color:#e2e8f0; overscroll-behavior-y:none; height:100dvh; width:100%; overflow:hidden; }
    .font-mono { font-family: 'JetBrains Mono', monospace; }
    #root { height:100dvh; width:100%; overflow:hidden; display:flex; flex-direction:column; }
    .matrix-bg { background-color:#020617; background-image: radial-gradient(circle at 50% 0%, #1e293b 0%, transparent 70%), radial-gradient(#1e293b 1px, transparent 1px); background-size:100% 100%, 30px 30px; }
    .glass-panel { background: rgba(15,23,42,0.6); backdrop-filter: blur(16px); -webkit-backdrop-filter: blur(16px); border:1px solid rgba(255,255,255,0.08); }
    .nav-pill { background: rgba(2,6,23,0.9); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px); border:1px solid rgba(255,255,255,0.1); box-shadow: 0 10px 40px -10px rgba(0,0,0,0.5); }
    .darth-mode .nav-pill { background: rgba(20,0,0,0.9); border-color: rgba(239,68,68,0.3); box-shadow:0 10px 40px -10px rgba(220,38,38,0.2); }
    .scan-line { width:100%; height:2px; background:#06b6d4; position:absolute; animation: scan 2s linear infinite; box-shadow:0 0 15px #06b6d4; }
    .darth-scan-line { background:#ef4444 !important; box-shadow:0 0 15px #ef4444 !important; }
    @keyframes scan { 0% { top:0%; opacity:0 } 50% { opacity:1 } 100% { top:100%; opacity:0 } }
    .anim-enter { animation: enterUp 0.4s cubic-bezier(0.16,1,0.3,1); }
    .anim-pop { animation: popIn 0.3s cubic-bezier(0.34,1.56,0.64,1); }
    @keyframes enterUp { from { opacity:0; transform: translateY(20px); } to { opacity:1; transform: translateY(0); } }
    @keyframes popIn { from { opacity:0; transform: scale(0.9); } to { opacity:1; transform: scale(1); } }
    input[type=range] { -webkit-appearance:none; width:100%; background:transparent; }
    input[type=range]::-webkit-slider-thumb { -webkit-appearance:none; height:16px; width:16px; border-radius:50%; background:currentColor; cursor:pointer; margin-top:-6px; box-shadow:0 2px 6px rgba(0,0,0,0.3); }
    input[type=range]::-webkit-slider-runnable-track { width:100%; height:4px; cursor:pointer; background:rgba(255,255,255,0.1); border-radius:2px; }
    .scrollbar-hide::-webkit-scrollbar { display:none; }
    .touch-scroll { -webkit-overflow-scrolling: touch; }
    .typing-animation { overflow:hidden; border-right:.15em solid #06b6d4; white-space:nowrap; animation: typing 3.5s steps(40,end), blink-caret .75s step-end infinite; }
    @keyframes typing { from { width:0 } to { width:100% } }
    @keyframes blink-caret { from, to { border-color: transparent } 50% { border-color: currentColor } }
  </style>
</head>

<body class="matrix-bg selection:bg-cyan-500 selection:text-white">
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    // --- PROTOCOL & CONFIG ---
    const PROTOCOL = {
      VERSION: '2.5-HARDENED-REPLAY-IDB',
      QR_CHUNK_SIZE: 350,
      DEFAULT_QR_FPS: 200,
      MAX_PACKET_SIZE: 5000,
      TS_WINDOW: 120000,
      CHUNK_TIMEOUT: 60000,
      REPLAY_TTL: 120000,       // 2 minutes TTL for nonces and mids
      HANDSHAKE_REPLY_TTL: 120000 // handshake reply shown expires after 2 minutes
    };

    // --- ICONS ---
    const Icon = ({ p, size=24, className="" }) => (
      <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>{p}</svg>
    );
    const icons = {
      shield: <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/>,
      skull: <><path d="M12 2c-4 0-8 3-8 8 0 1.5.5 3 1.5 4C4 16 3 22 3 22h18s-1-6-2.5-8c1-1 1.5-2.5 1.5-4 0-5-4-8-8-8z"/><path d="M8 10h.01"/><path d="M16 10h.01"/><path d="M10 14h4"/></>,
      lock: <><rect x="3" y="11" width="18" height="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/></>,
      qr: <rect x="3" y="3" width="18" height="18" rx="2" ry="2" />,
      send: <><line x1="22" y1="2" x2="11" y2="13"/><polygon points="22 2 15 22 11 13 2 9 22 2"/></>,
      scan: <><path d="M3 7V5a2 2 0 0 1 2-2h2"/><path d="M17 3h2a2 2 0 0 1 2 2v2"/><path d="M21 17v2a2 2 0 0 1-2 2h-2"/><path d="M7 21H5a2 2 0 0 1-2-2v-2"/></>,
      file: <><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/></>,
      bug: <><rect x="8" y="6" width="8" height="12" rx="4"/><path d="M12 12v.01"/><path d="M4 14h4"/><path d="M16 14h4"/></>
    };

    // --- CRYPTO HELPERS ---
    const buf2hex = (buf) => [...new Uint8Array(buf)].map(x => x.toString(16).padStart(2,'0')).join('');
    const hex2buf = (hex) => new Uint8Array(hex.match(/.{1,2}/g).map(byte => parseInt(byte,16))).buffer;
    const uint8ToB64 = (u8) => btoa(String.fromCharCode(...u8));
    const b64ToUint8 = (b64) => Uint8Array.from(atob(b64), c => c.charCodeAt(0));

    async function generateFingerprint(buffer) {
      const hash = await window.crypto.subtle.digest('SHA-256', buffer);
      const arr = new Uint8Array(hash);
      const emojis = ["ğŸ¶","ğŸ±","ğŸ­","ğŸ¹","ğŸ°","ğŸ¦Š","ğŸ»","ğŸ¼","ğŸ¨","ğŸ¯","ğŸ¦","ğŸ®","ğŸ·","ğŸ¸","ğŸµ","ğŸ”","ğŸ§","ğŸ¦","ğŸ¤","ğŸ¦†","ğŸ¦…","ğŸ¦‰","ğŸ¦‡","ğŸº","ğŸ—","ğŸ´","ğŸ¦„","ğŸ","ğŸ›","ğŸ¦‹","ğŸŒ","ğŸ","ğŸœ","ğŸ•·","ğŸ•¸","ğŸ¢","ğŸ","ğŸ¦","ğŸ¦‚","ğŸ¦€","ğŸ¦‘","ğŸ™","ğŸ¦","ğŸ ","ğŸŸ","ğŸ¡","ğŸ¬","ğŸ¦ˆ","ğŸ³","ğŸ‹","ğŸŠ","ğŸ†","ğŸ…","ğŸƒ","ğŸ‚","ğŸ„","ğŸª","ğŸ«","ğŸ˜","ğŸ¦","ğŸ¦","ğŸ","ğŸ–","ğŸ","ğŸ","ğŸ‘","ğŸ•","ğŸ©","ğŸˆ","ğŸ“","ğŸ¦ƒ","ğŸ•Š","ğŸ‡","ğŸ","ğŸ€","ğŸ¿","ğŸ¾"];
      let em = "";
      for (let i=0; i<4; i++) em += emojis[arr[i] % emojis.length];
      const hex = buf2hex(hash).substring(0, 32).toUpperCase();
      return { emoji: em, hex: hex, full: buf2hex(hash) };
    }

    // --- INDEXEDDB HELPERS (simple) ---
    const IDB_NAME = 'crypton-replay-db';
    const IDB_VERSION = 1;
    const NONCE_STORE = 'nonces';
    const MID_STORE = 'mids';
    const HANDSHAKE_STORE = 'handshakes'; // optional: store handshake replies (for expiry across reloads)

    function openDB() {
      return new Promise((resolve, reject) => {
        const req = indexedDB.open(IDB_NAME, IDB_VERSION);
        req.onupgradeneeded = (e) => {
          const db = e.target.result;
          if (!db.objectStoreNames.contains(NONCE_STORE)) db.createObjectStore(NONCE_STORE, { keyPath: 'k' });
          if (!db.objectStoreNames.contains(MID_STORE)) db.createObjectStore(MID_STORE, { keyPath: 'k' });
          if (!db.objectStoreNames.contains(HANDSHAKE_STORE)) db.createObjectStore(HANDSHAKE_STORE, { keyPath: 'k' });
        };
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      });
    }

    async function idbPut(store, key, value, expireAt) {
      const db = await openDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(store, 'readwrite');
        const s = tx.objectStore(store);
        s.put({ k: key, v: value, exp: expireAt });
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
      });
    }

    async function idbHasValid(store, key) {
      const db = await openDB();
      return new Promise((resolve) => {
        const tx = db.transaction(store, 'readonly');
        const s = tx.objectStore(store);
        const r = s.get(key);
        r.onsuccess = () => {
          const val = r.result;
          if (!val) return resolve(false);
          if (Date.now() > val.exp) {
            // expired -> delete
            const dtx = db.transaction(store, 'readwrite');
            dtx.objectStore(store).delete(key);
            dtx.oncomplete = () => resolve(false);
            dtx.onerror = () => resolve(false);
          } else resolve(true);
        };
        r.onerror = () => resolve(false);
      });
    }

    async function idbDelete(store, key) {
      const db = await openDB();
      return new Promise((resolve) => {
        const tx = db.transaction(store, 'readwrite');
        tx.objectStore(store).delete(key);
        tx.oncomplete = () => resolve();
        tx.onerror = () => resolve();
      });
    }

    async function idbGetAllValid(store) {
      const db = await openDB();
      return new Promise((resolve) => {
        const tx = db.transaction(store, 'readonly');
        const s = tx.objectStore(store);
        const req = s.getAll();
        req.onsuccess = () => {
          const now = Date.now();
          const filtered = (req.result || []).filter(item => item.exp > now).map(it => it.k);
          resolve(filtered);
        };
        req.onerror = () => resolve([]);
      });
    }

    // --- PERSISTENT REPLAY CACHE WRAPPERS (in-memory + IDB) ---
    function createPersistentCache(storeName) {
      const mem = new Map();

      // initialize from IDB
      (async () => {
        try {
          const keys = await idbGetAllValid(storeName);
          for (const k of keys) mem.set(k, true);
        } catch(e) {
          console.warn('idb load fail', e);
        }
      })();

      return {
        async has(key) {
          if (mem.has(key)) return true;
          try {
            const exists = await idbHasValid(storeName, key);
            if (exists) mem.set(key, true);
            return exists;
          } catch(e) {
            return false;
          }
        },
        async add(key, ttl = PROTOCOL.REPLAY_TTL) {
          mem.set(key, true);
          try {
            await idbPut(storeName, key, true, Date.now() + ttl);
          } catch(e) {
            console.warn('idb put fail', e);
          }
        },
        async delete(key) {
          mem.delete(key);
          try { await idbDelete(storeName, key); } catch(e) {}
        }
      };
    }

    const nonceStore = createPersistentCache(NONCE_STORE);
    const midStore = createPersistentCache(MID_STORE);

    // --- UI: Confirm Modal ---
    const ConfirmModal = ({ open, title, body, onConfirm, onCancel }) => {
      if (!open) return null;
      return (
        <div className="fixed inset-0 z-[200] flex items-center justify-center bg-black/60">
          <div className="bg-white/95 rounded-xl p-6 max-w-sm text-slate-900">
            <h3 className="font-bold mb-2">{title}</h3>
            <pre className="text-sm mb-4 whitespace-pre-wrap">{body}</pre>
            <div className="flex justify-end gap-3">
              <button onClick={onCancel} className="px-3 py-2 rounded bg-slate-200">Cancel</button>
              <button onClick={onConfirm} className="px-3 py-2 rounded bg-cyan-600 text-white">Confirm</button>
            </div>
          </div>
        </div>
      );
    };

    const QRDisplay = ({ data, label, subLabel, expiryAt }) => {
      const canvasRef = useRef(null);
      const [now, setNow] = useState(Date.now());

      useEffect(() => {
        if (canvasRef.current && data) {
          new QRious({ element: canvasRef.current, value: data, size: 256, level: 'L', foreground: 'black', background: 'white' });
        }
      }, [data]);

      // countdown if expiryAt provided
      useEffect(() => {
        if (!expiryAt) return;
        const id = setInterval(() => setNow(Date.now()), 500);
        return () => clearInterval(id);
      }, [expiryAt]);

      let countdown = null;
      if (expiryAt) {
        const diff = expiryAt - now;
        countdown = diff > 0 ? `${Math.ceil(diff/1000)}s` : 'expired';
      }

      return (
        <div className="bg-white p-3 rounded-2xl shadow-xl flex flex-col items-center anim-pop">
          <canvas ref={canvasRef} className="max-w-full h-auto border-4 border-white rounded-lg" />
          {label && (
            <div className="mt-3 text-center w-full">
              <p className="text-slate-900 font-bold text-sm tracking-tight">{label}</p>
              {subLabel && <p className="text-slate-400 text-[10px] font-mono uppercase truncate">{subLabel}{expiryAt ? ` â€¢ ${countdown}` : ''}</p>}
            </div>
          )}
        </div>
      );
    };

    const AnimatedQR = ({ chunks, label, onClose, theme="cyan" }) => {
      const [index, setIndex] = useState(0);
      const [speed, setSpeed] = useState(PROTOCOL.DEFAULT_QR_FPS);
      const [isPaused, setIsPaused] = useState(false);
      const isMultiChunk = chunks.length > 1;

      useEffect(() => {
        if (isPaused || !isMultiChunk) return;
        const interval = setInterval(() => setIndex(prev => (prev + 1) % chunks.length), speed);
        return () => clearInterval(interval);
      }, [chunks, speed, isPaused, isMultiChunk]);

      const btnClass = theme === "red" ? "bg-red-600 hover:bg-red-500" : "bg-cyan-600 hover:bg-cyan-500";

      return (
        <div className="fixed inset-0 z-[100] bg-slate-950/95 backdrop-blur-sm flex flex-col items-center justify-center p-6 anim-enter">
          <div className="relative w-full max-w-sm">
            <QRDisplay data={chunks[index]} label={label} subLabel={isMultiChunk ? `Part ${index+1}/${chunks.length}` : 'Single Block'} />
            {isMultiChunk && (
              <div className="mt-6 bg-white/5 p-4 rounded-2xl border border-white/10 space-y-4 anim-enter">
                <div className="flex items-center gap-3">
                  <span className="text-[10px] font-bold text-slate-500 w-6">SCRUB</span>
                  <input type="range" min="0" max={chunks.length-1} value={index} onChange={(e)=>{setIndex(parseInt(e.target.value)); setIsPaused(true);}} className={theme === "red" ? "text-red-500" : "text-cyan-500"} />
                </div>
                <div className="flex items-center gap-3">
                  <span className="text-[10px] font-bold text-slate-500 w-6">SPEED</span>
                  <input type="range" min="50" max="1000" step="50" value={speed} onChange={(e)=>setSpeed(parseInt(e.target.value))} className={theme === "red" ? "text-red-500" : "text-cyan-500"} />
                </div>
                <div className="flex justify-center gap-6 pt-2">
                  <button onClick={()=>setIndex(prev=>(prev-1+chunks.length)%chunks.length)} className="p-2 rounded-full bg-slate-800 text-slate-300 hover:bg-slate-700 transition-colors"><Icon p={icons.send} className="rotate-180 scale-75"/></button>
                  <button onClick={()=>setIsPaused(!isPaused)} className={`p-4 rounded-full text-white shadow-lg transition-transform active:scale-95 ${btnClass}`}><Icon p={icons.send} /></button>
                  <button onClick={()=>setIndex(prev=>(prev+1)%chunks.length)} className="p-2 rounded-full bg-slate-800 text-slate-300 hover:bg-slate-700 transition-colors"><Icon p={icons.send} className="scale-75"/></button>
                </div>
              </div>
            )}
            <button onClick={onClose} className="mt-8 mx-auto w-12 h-12 rounded-full bg-slate-800/50 flex items-center justify-center text-white/50 hover:bg-slate-800 hover:text-white transition-all border border-white/10">
              <Icon p={icons.qr} />
            </button>
          </div>
        </div>
      );
    };

    const QRScanner = ({ onScan, onClose, isDarth }) => {
      const videoRef = useRef(null);
      const canvasRef = useRef(null);
      const [error, setError] = useState(null);

      useEffect(() => {
        let stream;
        let animFrame;
        navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } })
          .then(s => {
            stream = s;
            if (videoRef.current) {
              videoRef.current.srcObject = s;
              videoRef.current.play();
              requestAnimationFrame(tick);
            }
          })
          .catch(err => setError("Camera access denied."));

        const tick = () => {
          if (videoRef.current && videoRef.current.readyState === 4) {
            const cvs = canvasRef.current;
            const vid = videoRef.current;
            cvs.width = vid.videoWidth; cvs.height = vid.videoHeight;
            const ctx = cvs.getContext("2d", { willReadFrequently: true });
            ctx.drawImage(vid, 0, 0);
            const img = ctx.getImageData(0, 0, cvs.width, cvs.height);
            const code = jsQR(img.data, img.width, img.height);
            if (code) onScan(code.data);
          }
          animFrame = requestAnimationFrame(tick);
        };

        return () => {
          if (stream) stream.getTracks().forEach(t => t.stop());
          cancelAnimationFrame(animFrame);
        };
      }, []);

      return (
        <div className="fixed inset-0 z-[100] bg-black flex flex-col items-center justify-center p-4 anim-enter">
          {error ? (
            <div className="text-red-500 text-center bg-slate-900 p-6 rounded-2xl border border-red-900/50">
              <p className="mb-4 font-bold">{error}</p>
              <button onClick={onClose} className="bg-slate-800 px-6 py-2 rounded-full text-sm">Close</button>
            </div>
          ) : (
            <div className={`relative w-full max-w-sm aspect-square bg-slate-900 rounded-[2rem] overflow-hidden border-4 shadow-2xl transition-colors duration-300 ${isDarth ? 'border-red-600 shadow-red-900/40' : 'border-cyan-500 shadow-cyan-900/40'}`}>
              <video ref={videoRef} className="absolute inset-0 w-full h-full object-cover" playsInline muted />
              <canvas ref={canvasRef} className="hidden" />
              <div className={`scan-line ${isDarth ? 'darth-scan-line' : ''}`}></div>
              <div className="absolute inset-0 border-[30px] border-black/30 rounded-[2rem] pointer-events-none"></div>
            </div>
          )}
          <button onClick={onClose} className="mt-8 px-6 py-3 rounded-full bg-white/10 backdrop-blur-md text-white font-semibold flex items-center gap-2 hover:bg-white/20 transition-all">
            Cancel Scan
          </button>
        </div>
      );
    };

    // --- MAIN APP ---
    const App = () => {
      const [mode, setMode] = useState('NORMAL');
      const [activeTab, setActiveTab] = useState('CONNECT');
      const [keys, setKeys] = useState(null);
      const [identityPayload, setIdentityPayload] = useState(null);
      const [handshakeReply, setHandshakeReply] = useState(null); // JSON string
      const [handshakeReplyExpiry, setHandshakeReplyExpiry] = useState(null); // timestamp ms
      const [pendingReply, setPendingReply] = useState(null); // object until user confirms
      const [sessionKey, setSessionKey] = useState(null);
      const [fingerprint, setFingerprint] = useState(null);
      const [scanner, setScanner] = useState(null);
      const [chat, setChat] = useState([]);
      const [msg, setMsg] = useState("");
      const [fileTransfer, setFileTransfer] = useState(null);
      const [interceptedPacket, setInterceptedPacket] = useState(null);
      const [showPill, setShowPill] = useState(true);

      const [confirmModal, setConfirmModal] = useState({ open:false, title:'', body:'', onConfirm:null, onCancel:null });
      const recvBuffers = useRef({}); // mid -> { total, chunks: {seq:data}, ts }

      const handshakeClearTimer = useRef(null);
      const lastScanRef = useRef("");
      const chatEndRef = useRef(null);
      const lastScrollY = useRef(0);

      useEffect(() => { if (scanner) lastScanRef.current = ""; }, [scanner]);
      useEffect(() => { chatEndRef.current?.scrollIntoView({ behavior: "smooth" }); }, [chat]);

      // periodic purge of stale chunk buffers
      useEffect(() => {
        const id = setInterval(() => {
          const now = Date.now();
          for (const mid of Object.keys(recvBuffers.current)) {
            if (now - recvBuffers.current[mid].ts > PROTOCOL.CHUNK_TIMEOUT) {
              delete recvBuffers.current[mid];
            }
          }
        }, Math.max(2000, PROTOCOL.CHUNK_TIMEOUT/4));
        return () => clearInterval(id);
      }, []);

      const handleScroll = (e) => {
        const currentScrollY = e.target.scrollTop;
        if (currentScrollY < 10) setShowPill(true);
        else if (currentScrollY > lastScrollY.current) setShowPill(false);
        else setShowPill(true);
        lastScrollY.current = currentScrollY;
      };

      // --- Key generation ---
      const genKeys = async () => {
        setKeys(null); setSessionKey(null); setFingerprint(null); setChat([]);
        const rsa = await window.crypto.subtle.generateKey(
          { name: "RSA-OAEP", modulusLength: 2048, publicExponent: new Uint8Array([1,0,1]), hash: "SHA-256" },
          false, // private non-extractable
          ["encrypt", "decrypt"]
        );
        const ecdh = await window.crypto.subtle.generateKey(
          { name: "ECDH", namedCurve: "P-256" },
          false,
          ["deriveKey", "deriveBits"]
        );
        setKeys({ rsa, ecdh });
        const rsaExp = await window.crypto.subtle.exportKey('spki', rsa.publicKey);
        const rsaStr = btoa(String.fromCharCode(...new Uint8Array(rsaExp)));
        const myFp = await generateFingerprint(rsaExp);
        const nonce = buf2hex(window.crypto.getRandomValues(new Uint8Array(12)));
        setIdentityPayload({ t: "ID", k: rsaStr, fp: myFp.hex, n: nonce, ts: Date.now() });
        // persist our own nonce as seen
        nonceStore.add(nonce);
      };

      useEffect(() => { genKeys(); }, []);

      // --- Reassembly helper for incoming chunks ---
      const handleIncomingChunk = (chunkObjRaw) => {
        const { mid, seq, total, payload } = chunkObjRaw;
        if (!mid || !seq || !total || typeof payload !== 'string') return;

        // async check mid store to avoid replays
        (async () => {
          if (await midStore.has(mid)) {
            console.warn("Duplicate mid ignored:", mid);
            return;
          }
          if (!recvBuffers.current[mid]) {
            recvBuffers.current[mid] = { total, chunks: {}, ts: Date.now() };
          }
          recvBuffers.current[mid].chunks[seq] = payload;

          const receivedCount = Object.keys(recvBuffers.current[mid].chunks).length;
          if (receivedCount === total) {
            const parts = [];
            for (let i=1;i<=total;i++) parts.push(recvBuffers.current[mid].chunks[i] || '');
            const assembled = parts.join('');
            // mark mid as seen
            await midStore.add(mid);
            delete recvBuffers.current[mid];
            try {
              const assembledObj = JSON.parse(assembled);
              if (!assembledObj.mid) assembledObj.mid = mid;
              await processScannedPacketObject(assembledObj);
            } catch (e) {
              console.warn("Failed to parse assembled packet", e);
            }
          }
        })();
      };

      // unified packet processing
      const processScannedPacketObject = async (p) => {
        try {
          if (!p || typeof p !== 'object') return;

          if (p.mid) {
            if (await midStore.has(p.mid)) throw new Error("Duplicate message mid (replay)");
            await midStore.add(p.mid);
          }

          if (p.t === "ID") {
            if (!keys) { alert("Local keys not ready."); return; }
            if (p.ts && Math.abs(Date.now() - p.ts) > PROTOCOL.TS_WINDOW) throw new Error("Identity QR expired");
            if (p.n && await nonceStore.has(p.n)) throw new Error("Nonce replay detected");

            const kData = Uint8Array.from(atob(p.k), c => c.charCodeAt(0));
            const partnerRsa = await window.crypto.subtle.importKey("spki", kData, { name:"RSA-OAEP", hash:"SHA-256" }, true, ["encrypt"]);
            const myEcdhRaw = await window.crypto.subtle.exportKey("raw", keys.ecdh.publicKey);
            const encEcdh = await window.crypto.subtle.encrypt({ name:"RSA-OAEP" }, partnerRsa, myEcdhRaw);
            const salt = window.crypto.getRandomValues(new Uint8Array(16));
            const reply = { t: "HSH", d: buf2hex(encEcdh), s: buf2hex(salt), n: p.n || null, ts: Date.now() };

            // show confirmation to user before emitting handshake reply
            setPendingReply(reply);
            setConfirmModal({
              open: true,
              title: "Partner Identity Scanned",
              body: `Fingerprint: ${p.fp}\n\nVerify visually. Confirm to send handshake reply (HSH).`,
              onConfirm: async () => {
                const json = JSON.stringify(reply);
                setHandshakeReply(json);
                const expiry = Date.now() + PROTOCOL.HANDSHAKE_REPLY_TTL;
                setHandshakeReplyExpiry(expiry);
                // persist handshake if desired (optional)
                try { await idbPut(HANDSHAKE_STORE, 'last_hsh', json, expiry); } catch(e) {}
                // start auto-clear timer for handshake reply
                if (handshakeClearTimer.current) clearTimeout(handshakeClearTimer.current);
                handshakeClearTimer.current = setTimeout(() => {
                  setHandshakeReply(null);
                  setHandshakeReplyExpiry(null);
                }, PROTOCOL.HANDSHAKE_REPLY_TTL);
                // mark incoming nonce as seen
                if (p.n) await nonceStore.add(p.n);
                setPendingReply(null);
                setConfirmModal({ open:false, title:'', body:'', onConfirm:null, onCancel:null });
                alert("Handshake reply generated. Show it to partner.");
              },
              onCancel: () => {
                setPendingReply(null);
                setConfirmModal({ open:false, title:'', body:'', onConfirm:null, onCancel:null });
              }
            });
          }
          else if (p.t === "HSH") {
            if (!keys) return;
            if (!p.ts || Math.abs(Date.now() - p.ts) > PROTOCOL.TS_WINDOW) throw new Error("Handshake expired or timestamp missing");
            if (identityPayload && identityPayload.n && p.n && identityPayload.n !== p.n) throw new Error("Nonce mismatch â€” possible replay");

            const encBuf = hex2buf(p.d);
            const partnerEcdhRaw = await window.crypto.subtle.decrypt({ name:"RSA-OAEP" }, keys.rsa.privateKey, encBuf);
            const partnerEcdhKey = await window.crypto.subtle.importKey("raw", partnerEcdhRaw, { name:"ECDH", namedCurve:"P-256" }, true, []);
            const sharedBits = await window.crypto.subtle.deriveBits({ name:"ECDH", public: partnerEcdhKey }, keys.ecdh.privateKey, 256);
            const salt = p.s ? hex2buf(p.s) : new Uint8Array(16);
            const info = new TextEncoder().encode(`Crypton_Secure_Session_v2:${PROTOCOL.VERSION}:initiator`);
            const hkdfKey = await window.crypto.subtle.importKey("raw", sharedBits, { name: "HKDF" }, false, ["deriveKey"]);
            const sessionKeyLocal = await window.crypto.subtle.deriveKey({
              name: "HKDF",
              hash: "SHA-256",
              salt: salt,
              info: info
            }, hkdfKey, { name: "AES-GCM", length: 256 }, false, ["encrypt","decrypt"]);
            const fp = await generateFingerprint(sharedBits);
            setSessionKey(sessionKeyLocal);
            setFingerprint(fp);
            setActiveTab('VERIFY');
            if (identityPayload && identityPayload.n) await nonceStore.add(identityPayload.n);
            alert("Handshake Complete. Secure Tunnel Established.");
          }
          else if (p.iv) {
            if (!sessionKey) throw new Error("No secure session.");
            const iv = hex2buf(p.iv);
            const ct = hex2buf(p.d);
            const pt = await window.crypto.subtle.decrypt({ name:"AES-GCM", iv }, sessionKey, ct);
            const text = new TextDecoder().decode(pt);
            setChat(prev => [...prev, { from:'Partner', text }]);
            setActiveTab('CHAT');
          }
        } catch (e) {
          console.error(e);
          alert("Security Check Failed: Packet rejected.");
        }
      };

      // handle scanned raw QR
      const handleScan = async (raw) => {
        if (raw === lastScanRef.current) return;
        if (typeof raw !== 'string') return;
        if (raw.length > PROTOCOL.MAX_PACKET_SIZE) {
          console.warn("Dropped oversized packet");
          alert("Scan rejected: packet too large.");
          return;
        }
        lastScanRef.current = raw;
        if (mode === 'DARTH') {
          setScanner(null);
          setInterceptedPacket({ raw, time: new Date().toLocaleTimeString() });
          return;
        }

        try {
          const parsed = JSON.parse(raw);
          if (parsed.mid && parsed.seq && parsed.total && parsed.payload) {
            handleIncomingChunk(parsed);
          } else {
            await processScannedPacketObject(parsed);
          }
        } catch (e) {
          console.error("Parse error", e);
          alert("Scan Error or invalid QR data.");
        } finally {
          setScanner(null);
        }
      };

      // --- Sending messages (chunking + mid) ---
      const sendMessage = async () => {
        if (!msg || !sessionKey) return;
        const iv = window.crypto.getRandomValues(new Uint8Array(12));
        const enc = await window.crypto.subtle.encrypt({ name:"AES-GCM", iv }, sessionKey, new TextEncoder().encode(msg));
        const packet = { iv: buf2hex(iv), d: buf2hex(enc) };
        const json = JSON.stringify(packet);

        const rawChunks = json.length > PROTOCOL.QR_CHUNK_SIZE ? json.match(new RegExp(`.{1,${PROTOCOL.QR_CHUNK_SIZE}}`, 'g')) : [json];
        const mid = buf2hex(window.crypto.getRandomValues(new Uint8Array(8)));
        const chunks = rawChunks.map((c, i) => JSON.stringify({ mid, seq: i+1, total: rawChunks.length, payload: c }));

        setFileTransfer({ chunks, label: "Encrypted Message" });
        await midStore.add(mid);
        setChat(prev => [...prev, { from:'Me', text: msg, isTyping: true }]);
        setMsg("");
        setTimeout(() => setChat(prev => prev.map(c => c.isTyping ? { ...c, isTyping:false } : c)), 1000);
      };

      const darthTamper = () => {
        if (!interceptedPacket) return;
        let badRaw = interceptedPacket.raw.replace(/[a-fA-F0-9]/, "X");
        try {
          const p = JSON.parse(interceptedPacket.raw);
          if (p.d) p.d = p.d.replace(/^../, "FF");
          badRaw = JSON.stringify(p);
        } catch(e) {}
        const id = Math.random().toString(36).substr(2,5);
        setFileTransfer({ chunks: [badRaw], label: `Tampered Packet #${id}`, theme: "red" });
      };

      // toggle mode
      const toggleMode = () => {
        setMode(mode === 'NORMAL' ? 'DARTH' : 'NORMAL');
        setScanner(null);
        setInterceptedPacket(null);
        setActiveTab(mode === 'NORMAL' ? 'DARTH' : 'CONNECT');
      };

      const truncate = (s, n=200) => s && s.length > n ? s.substring(0,n) + 'â€¦' : s;

      // clear handshake reply on unmount
      useEffect(() => {
        return () => { if (handshakeClearTimer.current) clearTimeout(handshakeClearTimer.current); };
      }, []);

      // Load persisted handshake reply if unexpired on load
      useEffect(() => {
        (async () => {
          try {
            const db = await openDB();
            const tx = db.transaction(HANDSHAKE_STORE, 'readonly');
            const s = tx.objectStore(HANDSHAKE_STORE);
            const req = s.get('last_hsh');
            req.onsuccess = () => {
              const val = req.result;
              if (val && val.exp && Date.now() < val.exp) {
                setHandshakeReply(val.v);
                setHandshakeReplyExpiry(val.exp);
                // set auto clear
                if (handshakeClearTimer.current) clearTimeout(handshakeClearTimer.current);
                handshakeClearTimer.current = setTimeout(() => { setHandshakeReply(null); setHandshakeReplyExpiry(null); }, val.exp - Date.now());
              } else if (val && val.exp && Date.now() >= val.exp) {
                // expired -> delete
                idbDelete(HANDSHAKE_STORE, 'last_hsh');
              }
            };
          } catch(e) {}
        })();
      }, []);

      return (
        <div className={`h-full w-full flex flex-col relative transition-colors duration-700 ${mode === 'DARTH' ? 'darth-mode' : ''}`}>
          <ConfirmModal
            open={confirmModal.open}
            title={confirmModal.title}
            body={confirmModal.body}
            onConfirm={confirmModal.onConfirm}
            onCancel={confirmModal.onCancel}
          />

          <header className="px-6 py-4 flex justify-between items-center z-20 backdrop-blur-md bg-slate-950/30 border-b border-white/5 absolute top-0 w-full">
            <div className="flex items-center gap-3">
              <div className={`p-2 rounded-xl bg-gradient-to-br ${mode==='DARTH' ? 'from-red-600 to-red-800' : 'from-cyan-500 to-blue-600'} text-white shadow-lg`}><Icon p={mode==='DARTH' ? icons.skull : icons.shield} size={20} /></div>
              <div>
                <h1 className="font-bold text-lg leading-none tracking-tight">Crypton</h1>
                <span className={`text-[10px] font-bold tracking-widest ${mode==='DARTH' ? 'text-red-400' : 'text-cyan-400'} opacity-80`}>{mode==='DARTH' ? 'INTERCEPTOR ACTIVE' : `SECURE CHANNEL ${PROTOCOL.VERSION}`}</span>
              </div>
            </div>
            <div className="flex items-center gap-4">
              <button onClick={toggleMode} className={`w-8 h-8 rounded-full flex items-center justify-center border ${mode==='DARTH' ? 'border-red-500 text-red-400' : 'border-cyan-500 text-cyan-400'} hover:bg-white/5 transition-all`}><Icon p={icons.bug} size={16} /></button>
            </div>
          </header>

          <main className="flex-1 overflow-y-auto touch-scroll pt-48 pb-10 px-4 md:px-0" onScroll={handleScroll}>
            <div className="max-w-md md:max-w-5xl mx-auto h-full flex flex-col">
              {/* CONNECT */}
              {mode === 'NORMAL' && activeTab === 'CONNECT' && (
                <div className={`grid grid-cols-1 ${handshakeReply ? 'lg:grid-cols-2' : ''} gap-6 anim-enter items-start`}>
                  <div className="glass-panel p-6 rounded-3xl text-center space-y-4 w-full">
                    <div className="inline-block px-3 py-1 rounded-full bg-slate-800/50 border border-white/10 text-xs text-slate-400 font-mono mb-2">STEP 01</div>
                    <h2 className="text-2xl font-bold">Establish Identity</h2>
                    <div className="flex justify-center py-2">
                      {identityPayload && <QRDisplay data={JSON.stringify(identityPayload)} label="MY RSA IDENTITY" subLabel={identityPayload.fp.substring(0,16) + '...'} />}
                    </div>
                  </div>

                  {handshakeReply && (
                    <div className="bg-emerald-900/30 border border-emerald-900/30 p-6 rounded-3xl text-center space-y-4 anim-enter w-full h-[499px]">
                      <div className="inline-block px-3 py-1 rounded-full bg-emerald-500/20 text-xs text-emerald-400 font-bold mb-2">STEP 02</div>
                      <h2 className="text-xl font-bold text-emerald-100">Handshake Reply</h2>
                      <div className="flex justify-center">
                        <QRDisplay data={handshakeReply} label="SESSION DATA" subLabel="Show this back to partner" expiryAt={handshakeReplyExpiry} />
                      </div>
                    </div>
                  )}
                </div>
              )}

              {/* VERIFY */}
              {mode === 'NORMAL' && activeTab === 'VERIFY' && (
                <div className="space-y-6 anim-enter h-full flex flex-col justify-center max-w-md mx-auto w-full">
                  <div className="glass-panel p-8 rounded-[2.5rem] text-center space-y-6 shadow-2xl mt-12">
                    <div className={`w-20 h-20 mx-auto rounded-full flex items-center justify-center text-3xl shadow-lg ${sessionKey ? 'bg-emerald-500 text-emerald-950' : 'bg-slate-800 text-slate-500'}`}><Icon p={sessionKey ? icons.lock : icons.qr} size={36} /></div>
                    <div>
                      <h2 className="text-2xl font-bold mb-1">Status Report</h2>
                      <p className="font-mono text-xs tracking-widest">{sessionKey ? "AES-GCM-256 ENCRYPTED" : "NO ACTIVE SESSION"}</p>
                    </div>

                    {sessionKey && fingerprint && (
                      <div className="bg-black/40 p-6 rounded-2xl border border-white/5 space-y-3">
                        <p className="text-[10px] text-slate-500 uppercase tracking-widest font-bold">Safety Fingerprint</p>
                        <div className="text-5xl animate-pulse">{fingerprint.emoji}</div>
                        <div className="font-mono text-xl text-yellow-500 tracking-[0.2em] break-all leading-relaxed">{fingerprint.hex}</div>
                        <p className="text-xs text-slate-400 leading-relaxed pt-2 border-t border-white/5">Visually compare with partner.<br/>Matching icons + hex = No MitM.</p>
                      </div>
                    )}

                    {sessionKey && <button onClick={()=>setActiveTab('CHAT')} className="w-full bg-white text-black font-bold py-4 rounded-xl shadow-xl hover:bg-slate-200 transition-colors">Start Secure Chat</button>}
                  </div>
                </div>
              )}

              {/* CHAT */}
              {mode === 'NORMAL' && activeTab === 'CHAT' && (
                <div className="flex flex-col h-full anim-enter max-w-md mx-auto w-full">
                  <div className="flex-1 overflow-y-auto space-y-3 pb-24 scrollbar-hide">
                    {chat.length === 0 && <div className="text-center py-20 opacity-30"><Icon p={icons.shield} size={64} className="mx-auto mb-4"/><p>History is never stored.</p></div>}
                    {chat.map((c,i) => (<div key={i} className={`flex ${c.from==='Me'?'justify-end':''} anim-pop`}><div className={`max-w-[85%] px-5 py-3 rounded-2xl text-sm leading-relaxed shadow-sm ${c.from==='Me' ? 'bg-cyan-600 text-white rounded-br-none' : 'glass-panel text-slate-200 rounded-bl-none'}`}>{c.isTyping ? <div className="typing-animation opacity-70">Encrypting...</div> : c.text}</div></div>))}
                    <div ref={chatEndRef} />
                  </div>

                  <div className="glass-panel p-2 rounded-[2rem] flex items-center gap-2 mt-auto">
                    <button onClick={()=>setScanner('QR')} className="w-10 h-10 rounded-full bg-slate-800 text-slate-400 flex items-center justify-center hover:bg-slate-700 transition-colors"><Icon p={icons.qr} size={20}/></button>
                    <input value={msg} onChange={e=>setMsg(e.target.value)} className="flex-1 bg-transparent border-none outline-none text-white px-2 placeholder-slate-600" placeholder="Type a secure message..." />
                    <button onClick={sendMessage} disabled={!msg} className="w-10 h-10 rounded-full bg-cyan-500 text-black flex items-center justify-center hover:bg-cyan-400 disabled:opacity-50 disabled:cursor-not-allowed transition-all shadow-lg shadow-cyan-500/20"><Icon p={icons.send} size={18}/></button>
                  </div>
                </div>
              )}

              {/* FILES (Wave) */}
              {mode === 'NORMAL' && activeTab === 'FILES' && (
                <div className="h-full w-full anim-enter flex flex-col justify-center">
                  <div className="glass-panel p-8 rounded-[2.5rem] text-center space-y-6 shadow-2xl max-w-md mx-auto w-full">
                    <div className="w-20 h-20 mx-auto rounded-full flex items-center justify-center text-3xl shadow-lg bg-cyan-900/50 text-cyan-200"><Icon p={icons.file} size={36}/></div>
                    <div><h2 className="text-2xl font-bold mb-2">Wave-Share</h2><p className="text-xs text-slate-400">Encrypted P2P Transfer</p></div>
                    <div className="border-2 border-dashed border-white/10 rounded-2xl p-8 flex flex-col items-center gap-4"><a href="#" onClick={(e)=>e.preventDefault()} className="px-6 py-2 bg-slate-800 rounded-full text-xs font-bold hover:bg-slate-700 transition-colors">Coming Soon</a></div>
                  </div>
                </div>
              )}

              {/* DARTH */}
              {mode === 'DARTH' && (
                <div className="space-y-6 anim-enter max-w-md mx-auto w-full">
                  <div className="p-6 rounded-3xl bg-red-950/40 border border-red-900/50 backdrop-blur-xl relative overflow-hidden">
                    <div className="absolute top-0 right-0 p-8 text-red-600 opacity-20"><Icon p={icons.bug} size={120}/></div>
                    <h2 className="text-2xl font-bold text-red-100 mb-1">Packet Sniffer</h2>
                    <p className="text-red-400/60 text-xs mb-8">Intercept. Analyze. Corrupt.</p>

                    {!interceptedPacket ? (
                      <button onClick={()=>setScanner('QR')} className="w-full aspect-[4/3] border-2 border-dashed border-red-800 rounded-2xl flex flex-col items-center justify-center text-red-500/50 hover:bg-red-900/10 hover:border-red-500 hover:text-red-400 transition-all gap-3">
                        <Icon p={icons.qr} size={48}/>
                        <span className="font-mono text-sm tracking-widest">TAP TO INTERCEPT</span>
                      </button>
                    ) : (
                      <div className="space-y-4">
                        <div className="bg-black/60 p-4 rounded-xl font-mono text-[10px] break-all border-l-2 border-red-500 text-red-300/80">{truncate(interceptedPacket.raw, 600)}</div>
                        <div className="grid grid-cols-2 gap-3">
                          <button onClick={()=>{alert("Brute Force Failed: AES-256 Entropy too high.");}} className="py-3 rounded-xl bg-red-900/30 text-red-300 text-xs font-bold border border-red-900/50">BRUTE FORCE</button>
                          <button onClick={darthTamper} className="py-3 rounded-xl bg-red-600 text-white text-xs font-bold shadow-lg shadow-red-900/50">TAMPER & REPLAY</button>
                        </div>
                        <button onClick={()=>setInterceptedPacket(null)} className="w-full py-2 text-xs text-red-500/50">Discard Packet</button>
                      </div>
                    )}
                  </div>
                  <p className="text-center text-xs text-red-500/30 max-w-xs mx-auto">DARTH mode simulates MITM attacks. Tampered packets will fail GCM auth tags on receiver devices.</p>
                </div>
              )}
            </div>
          </main>

          {/* floating nav pill */}
          {mode === 'NORMAL' && (
            <div className={`fixed top-24 left-1/2 -translate-x-1/2 w-[95%] max-w-[380px] z-50 transition-transform duration-500 ${showPill ? 'translate-y-0' : '-translate-y-[300%]'}`}>
              <nav className="nav-pill rounded-full p-2 flex items-center justify-between relative">
                <button onClick={()=>setActiveTab('CONNECT')} className={`flex-1 flex flex-col items-center justify-center py-2 rounded-full transition-all duration-300 ${activeTab==='CONNECT' ? 'text-cyan-400' : 'text-slate-500 hover:text-slate-300'}`}><Icon p={icons.scan} size={20} /><span className={`text-[8px] font-bold mt-1 ${activeTab==='CONNECT' ? 'opacity-100' : 'opacity-0 h-0 overflow-hidden'}`}>CONNECT</span></button>
                <button onClick={()=>setActiveTab('VERIFY')} className={`flex-1 flex flex-col items-center justify-center py-2 rounded-full transition-all duration-300 ${activeTab==='VERIFY' ? 'text-emerald-400' : 'text-slate-500 hover:text-slate-300'}`}><Icon p={icons.shield} size={20} /><span className={`text-[8px] font-bold mt-1 ${activeTab==='VERIFY' ? 'opacity-100' : 'opacity-0 h-0 overflow-hidden'}`}>VERIFY</span></button>
                <div className="mx-1">
                  <button onClick={()=>setScanner('QR')} className="w-12 h-12 rounded-full bg-cyan-500 flex items-center justify-center text-slate-900 shadow-[0_0_20px_rgba(6,182,212,0.4)] hover:scale-105 hover:bg-cyan-400 transition-all active:scale-95 border-2 border-slate-900"><Icon p={icons.scan} size={24}/></button>
                </div>
                <button onClick={()=>setActiveTab('CHAT')} className={`flex-1 flex flex-col items-center justify-center py-2 rounded-full transition-all duration-300 ${activeTab==='CHAT' ? 'text-white' : 'text-slate-500 hover:text-slate-300'}`}><Icon p={icons.send} size={20}/><span className={`text-[8px] font-bold mt-1 ${activeTab==='CHAT' ? 'opacity-100' : 'opacity-0 h-0 overflow-hidden'}`}>CHAT</span></button>
                <button onClick={()=>sessionKey && setActiveTab('FILES')} disabled={!sessionKey} className={`flex-1 flex flex-col items-center justify-center py-2 rounded-full transition-all duration-300 ${!sessionKey ? 'opacity-30 grayscale cursor-not-allowed' : ''} ${activeTab==='FILES' ? 'text-purple-400' : 'text-slate-500 hover:text-slate-300'}`}><Icon p={icons.file} size={20} /><span className={`text-[8px] font-bold mt-1 ${sessionKey ? (activeTab==='FILES' ? 'opacity-100' : 'opacity-0 h-0 overflow-hidden') : 'opacity-0 h-0 overflow-hidden'}`}>FILES</span></button>
              </nav>
            </div>
          )}

          {/* MODALS */}
          {scanner === 'QR' && <QRScanner onScan={handleScan} onClose={()=>setScanner(null)} isDarth={mode==='DARTH'} />}
          {fileTransfer && <AnimatedQR chunks={fileTransfer.chunks} label={fileTransfer.label} theme={fileTransfer.theme} onClose={()=>setFileTransfer(null)} />}

        </div>
      );
    };

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
